
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.1.5">
    
    
      
        <title>第1回 - システム検証論 (2020)</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.21aed14c.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.196e0c26.min.css">
        
      
    
    
    
      
        
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/earlyaccess/notosansjp.css">
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:600,800">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href=".." title="システム検証論 (2020)" class="md-header-nav__button md-logo" aria-label="システム検証論 (2020)">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            システム検証論 (2020)
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              第1回
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="システム検証論 (2020)" class="md-nav__button md-logo" aria-label="システム検証論 (2020)">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    システム検証論 (2020)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        第1回
        <span class="md-nav__icon md-icon"></span>
      </label>
    
    <a href="./" class="md-nav__link md-nav__link--active">
      第1回
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    モデル検査とは
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    形式手法の必要性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    ハードウェア・ソフトウェアの検証技術
  </a>
  
    <nav class="md-nav" aria-label="ハードウェア・ソフトウェアの検証技術">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    シミュレーションとテスト
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    演繹的検証
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    モデル検査
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    モデル検査のプロセス
  </a>
  
    <nav class="md-nav" aria-label="モデル検査のプロセス">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    モデル化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    仕様の記述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    検証
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    時相論理とモデル検査
  </a>
  
    <nav class="md-nav" aria-label="時相論理とモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    時相論理とは
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    時相論理とプログラム証明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    モデル検査の複雑さ
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    記号的アルゴリズム
  </a>
  
    <nav class="md-nav" aria-label="記号的アルゴリズム">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    順序付き二分決定グラフ
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    記号モデル検査アルゴリズム
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smv" class="md-nav__link">
    SMV
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#obdd" class="md-nav__link">
    OBDD に基づくその他のアプローチ
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    半順序削減法
  </a>
  
    <nav class="md-nav" aria-label="半順序削減法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    ソフトウェア検証における問題
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    半順序モデルに基づく状態空間の削減
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    半順序削減法を用いたアルゴリズム
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    状態爆発へのその他のアプローチ
  </a>
  
    <nav class="md-nav" aria-label="状態爆発へのその他のアプローチ">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    部分検証
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    抽象化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    対称性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    帰納法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec02/" class="md-nav__link">
      第2回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec03/" class="md-nav__link">
      第3回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec04/" class="md-nav__link">
      第4回
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../lec05/" class="md-nav__link">
      第5回
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    モデル検査とは
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    形式手法の必要性
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    ハードウェア・ソフトウェアの検証技術
  </a>
  
    <nav class="md-nav" aria-label="ハードウェア・ソフトウェアの検証技術">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    シミュレーションとテスト
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    演繹的検証
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    モデル検査
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    モデル検査のプロセス
  </a>
  
    <nav class="md-nav" aria-label="モデル検査のプロセス">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    モデル化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    仕様の記述
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    検証
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    時相論理とモデル検査
  </a>
  
    <nav class="md-nav" aria-label="時相論理とモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    時相論理とは
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    時相論理とプログラム証明
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    モデル検査の複雑さ
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    記号的アルゴリズム
  </a>
  
    <nav class="md-nav" aria-label="記号的アルゴリズム">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    順序付き二分決定グラフ
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    記号モデル検査アルゴリズム
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smv" class="md-nav__link">
    SMV
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#obdd" class="md-nav__link">
    OBDD に基づくその他のアプローチ
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    半順序削減法
  </a>
  
    <nav class="md-nav" aria-label="半順序削減法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    ソフトウェア検証における問題
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    半順序モデルに基づく状態空間の削減
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    半順序削減法を用いたアルゴリズム
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    状態爆発へのその他のアプローチ
  </a>
  
    <nav class="md-nav" aria-label="状態爆発へのその他のアプローチ">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    部分検証
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    抽象化
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    対称性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    帰納法
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="1">第1回 モデル検査とは</h1>
<p>この回では，教科書の第2章 "Introduction to 1st Edition" について説明します．</p>
<div class="admonition 概要">
<p class="admonition-title">概要</p>
<ul>
<li>モデル検査とは</li>
<li>他の検証手法との比較</li>
<li>モデル検査のプロセス</li>
<li>モデル検査アルゴリズムの発展</li>
<li>状態爆発への対処</li>
</ul>
</div>
<h2 id="_1">モデル検査とは</h2>
<p>モデル検査 (model checking) は有限状態の並行システムを自動的に検証するための技術で，従来の検証技術（シミュレーション，テスト，演繹的推論）と比較していろいろな利点がある．
モデル検査は，順序回路の設計や通信プロトコルの検証に実際に使用されており，成功しているといえる．</p>
<p>一方で，<strong>状態爆発</strong>（state explosion）という大きな問題もある．
これは，相互作用する多くのコンポーネントをもつシステムや，多くの異なる値を仮定したデータ構造をもつシステムにおいて生じる問題で，グローバル状態の数が要素数に対して<strong>指数的に増加</strong>することに起因する．</p>
<h2 id="_2">形式手法の必要性</h2>
<p>ハードウェアおよびソフトウェアシステムは，電子商取引，電話交換ネットワーク，高速道路や航空交通の管制システム，医療機器など，障害が許容できないアプリケーションで広く使用されている．
そのため，システムのエラーが何らかの障害の原因となることも多い．
有名な事例では，1996 年 6 月 4 日に，打ち上げられて 40 秒も経たないうちに爆発したアリアン 5 ロケットの事故がある．
この事故の原因はロケットの動きを計算するコンピュータのソフトウェアのエラーだった．
事故調査委員会によると，打ち上げの最中，64 ビットの浮動小数点数が 16 ビットの符号付き整数に変換される際に例外が発生したが，この例外を処理するコードが書かれていなかったため，コンピュータの故障が起きてしまった．
そして，バックアップコンピュータでも同様に故障が起きてしまい，誤った高度データが送信されて，ロケットの爆発という結果を招いてしまった．</p>
<p>システムの信頼性向上は重要であることは明らかだが，システムが私たちの生活に関わることが多くなればなるほど，その正しさを保証するための負担も大きくなる．
システムの継続的稼働への依存性が高いため，機能不全のシステムをシャットダウンするのももはや現実的とはいえないし，シャットダウンする際に機器の安全性が低下するケースもある．
インターネットや，自動車，航空機などでの組込みシステムの普及により，計算機デバイスが正しく機能することへの依存度はどんどん高まっており，システムの正しさを保証する手法の開発は，今後ますます重要となる．</p>
<h2 id="_3">ハードウェア・ソフトウェアの検証技術</h2>
<p>複雑システムを対象とする主要な検証手法は，シミュレーション，テスト，演繹的検証，そしてモデル検査である．
それぞれの利点・欠点について以下で簡単に説明する．</p>
<h3 id="_4">シミュレーションとテスト</h3>
<p>シミュレーションとテストは，いずれもシステムを実地へと展開する前に実験を行うもので，違いとしてはシミュレーションが抽象化されたシステムに対して実行されるのに対し，テストは実際の製品に対して実行される．
例えばデジタル回路であれば，シミュレーションは回路の設計上で行われるし，テストは完成した回路そのものに対して実施される．
これらの手法はいずれも，システムに特定の入力を与えた上で，対応する出力を観察することで行われる．
利点としては，コスト効率よく多くのエラーを発見することができる．
しかしながら，起こり得る相互作用や潜在する危険をすべてチェックするのはほぼ不可能である.</p>
<h3 id="_5">演繹的検証</h3>
<p>演繹的検証（deductive verification）という用語は，通常は公理や推論規則を用いてシステムの正しさを証明することを指す．
初期の研究では，クリティカルシステムの正しさを保証することに主眼が置かれていたので，開発者や検証の専門家 (数学者や論理学者) がシステムの検証に時間をいくらでも費やせることが前提とされていた．
当初は証明がすべて人手で行われていたが，公理と推論規則の正しい使用を遵守させるソフトウェアツールを開発可能であることが，研究者に認識された．
このようなツールでは，機械的探索に基づいて，現時点の証明から進行しうるさまざまな選択肢を提示することが可能である．</p>
<p>演繹的検証の重要性は広く認識されており，ソフトウェア開発の分野にも多大な影響を与えてきた．
（例えば，不変式（invariant）の概念は演繹的検証の研究から生まれたものである．）
しかし，演繹的検証は時間のかかるプロセス（ときには，数日から数ヶ月を要することさえある）であり，実施にはかなりの専門知識を要する．
結果として，演繹的検証が利用されることは非常に稀で，安全に使用できることを保証するために十分なリソースを投資する必要がある，セキュリティ・プロトコルなどの機密性の高いシステムに対して適用される．</p>
<p>そもそも，ある種の数学的なタスクはアルゴリズム的に実現できないと認識する必要がある．
計算可能性（computability）の理論は，アルゴリズムで決定可能な問題に関する制約を与えており，特に，プログラムの停止性を判定可能なアルゴリズムが存在しないことを示している．
つまり，プログラムが正しく終了することを自動的に検証することは不可能であり，自動検証が可能な問題にも制約があることも示している．
したがって，ほとんどの証明系は完全に自動化することができない．</p>
<p>演繹的検証の利点は，無限の状態をもつシステムを証明できることである．
この処理は限られた範囲で自動化することも可能である．
しかし，仮に検証すべき性質が成り立っていたとしても，証明を見つけるために必要な時間やメモリの量に制約を設けることは不可能である．</p>
<h3 id="_6">モデル検査</h3>
<p>モデル検査は，<strong>有限状態</strong>の並行システムを対象とした検証技術となる．
こうした制限を設ける一つの利点として，検証を自動化することが可能となる．</p>
<p>モデル検査では，仕様が真かどうかを決定するために，システムの状態空間の網羅的探索 (exhaustive search) を行う．
十分なリソースが与えられていれば，この手続きは常に yes/no の答えとともに終了する．
さらに，この手続きは，中規模の計算機でも実行可能な程度の，十分に効率的なアルゴリズムによって実装できる．</p>
<p>有限状態への限定は大きな欠点のようにも見えるが，モデル検査はいくつかの非常に重要な問題へと適用可能である．
例えば，ハードウェアコントローラや多くの通信プロトコルは有限状態システムである．
有限状態でないシステムでも，さまざまな抽象化や帰納法と組み合わせることにより，モデル検査を用いることができる．
また，制限のないデータ構造を有限状態となる特定の例へと制限することで，エラーを発見できることも多い．
例えば，無制限のメッセージキューをもつプログラムを，キューのサイズを 2 または 3 といった小さい値へと制限することでデバッグすることができる．</p>
<p>モデル検査は自動化できるため，利用できるのであれば演繹的検証よりも望ましい．
しかし，完全な検証のために演繹的検証が必要となるような重要なアプリケーションは常に存在する．
一つの研究として，演繹的検証とモデル検査を統合することで，複雑なシステムの有限状態部分を自動的に検証する試みがなされている．</p>
<h2 id="_7">モデル検査のプロセス</h2>
<p>モデル検査を実際の問題へと適用するためのプロセスは，以下の３つのタスクへと分類される．</p>
<h3 id="_8">モデル化</h3>
<p>最初の作業は，設計をモデル検査ツールで扱えるようなある種の形式的な枠組みへと変換することである．
多くの場合，これは単なるコンパイル作業となる．
その他の場合，時間とメモリの制約から，関連がない，あるいは重要でない詳細部分を抽象化することが設計のモデル化において求められるかもしれない．</p>
<h3 id="_9">仕様の記述</h3>
<p>検証の前に，設計が満たすべき特性（仕様という）を何らかの枠組みに基づいて記述する必要がある．
モデル検査では，仕様の記述に，システムの動作が時間に伴ってどのように変化するかを記述する論理である，時相論理 (temporal logic) を用いることが一般的である．</p>
<p>仕様記述における重要な問題は，完全性（completeness）である．
モデル検査は，設計に対するモデルが与えられた仕様を満たすかどうかを判定することはできても，与えられた仕様がシステムが満たすべきすべての特性を網羅しているかどうかは判断できない．</p>
<h3 id="_10">検証</h3>
<p>検証作業は完全に自動化されるのが理想であるが，実際には人の手による補助を伴うことが多い．
その一つが，検証結果の分析である．
否定的な結果が得られた場合，モデル検査では<strong>反例</strong>（counter-example）と呼ばれる実行系列を得ることができる．
反例は仕様が満たされないことを示す実行系列で，エラーが発生した場所を追跡するために有用である．
反例の解析のため，システムに対する修正とモデル検査アルゴリズムの再適用を行う場合もある．</p>
<p>システムの誤ったモデル化や誤った仕様に起因して反例が生じること（しばしば false negative と呼ばれる）もあるが，反例解析は，こういった二つの問題を特定して修正することにも有用である．</p>
<p>最後の可能性として，モデルのサイズが大きすぎたために，検証が正常に終了しないこともある．
この場合，モデル検査ツールのパラメータを変更するか，モデルの修正（例えば，さらなる抽象化）を施した上で，検証をやり直すことになる．</p>
<h2 id="_11">時相論理とモデル検査</h2>
<h3 id="_12">時相論理とは</h3>
<p>もともと時相論理は哲学の分野において，自然言語における時間の用いられ方を議論するために開発されてきたものである．
時相論理は，時間を明示的に導入することなく時間に伴うイベントの順序を記述できることから，並行システムを特徴付けるのに有用である．
この教科書では，時相論理式の意味（つまり，式がどういうときに真と評価されるか）は，Kripke 構造と呼ばれるラベル付き状態遷移グラフを基に決定される．
時相論理は，時間の流れが線形（linear）構造をもつと仮定するか，分岐（branch）構造をもつと仮定するかによって分類される．</p>
<p>時相論理には様々なクラスがあるが，そのほとんどは \(\textbf{G}f\) という形式の演算子をもつ．
この式は，\(f\) が未来において常に真となる（つまり，\(f\) が大域的に (globally) 真である）場合，現在において真となる．
例えば，2 つの事象 \(e_1\) と \(e_2\) が同時に発生しないことを表現したい場合，\(\textbf{G}(\neg e_1 \vee \neg e_2)\) と書くことになる．</p>
<h3 id="_13">時相論理とプログラム証明</h3>
<p>Burstall，Kroger，Pnueli などの研究者たちはコンピュータプログラムの証明に時相論理を利用することを提案したが，並行性 (concurrency) についての証明に時相論理を用いたのは，Pnueli が最初の人物である．
Pnueli のアプローチは，プログラムの個々の文の振る舞いを記述した公理の集合を基に，対象となるプログラムの特性を証明するものだった．
Bochmann や Malachi と Owicki によって，この手法が順序回路へと拡張された．
証明は人手によって作成されるため，この手法を実際に使用するのは困難な場合が多かった．</p>
<p>1980 年代の初頭に Clarke と Emerson によって時相論理のモデル検査アルゴリズムが提案されたことで，証明を自動化できるようになった．
あるモデルがある式を満たすか検証することは，すべてのモデルについての式の妥当性を証明するよりはるかに簡単なので，この技術は非常に効率的に実装できた．
Clarke と Emerson が開発した分岐時間論理 CTL のモデル検査アルゴリズムは，検査対象システムのモデルと時相論理による仕様の両方のサイズに関して多項式（polynomial）時間であった．</p>
<p>さらに，アルゴリズムの複雑さを変えることなく公平性（fairness）を扱うための手法についても示した．
多くの並行プログラムの正しさは，ある種の公平性の仮定に依存することから，これは重要な一歩であった．
例えば，相互排他アルゴリズムにおいて飢餓状態（starvation）が存在しないことは，各プロセスが無限にしばしば（infinitely often）実行されるという仮定に依存する可能性がある．</p>
<div class="admonition tip">
<p class="admonition-title">公平性について</p>
<p>例えば，並行システムがある仕様を満たすか否かを議論するような状況を考えてみる．
このとき，複数のプロセスのどれか一つのみが延々と実行されたときその仕様は満たされない，という結果が得られたとしても，そんな極端な場合はそもそも考える必要がないことも多い．
こういう偏った実行系列を排除するための制約は，公平性制約と呼ばれる．
公平性制約として与えられた条件式が無限に満たされるような実行系列のみが，検証の対象となる．</p>
</div>
<p>ほぼ同時期に Queille と Sifakis も，CTL のサブセットを対象としたモデル検査アルゴリズムを提案している．
後に Clarke, Emerson, Sistla は，式の長さと状態遷移グラフの大きさの積に対して線形時間となる改良アルゴリズムを考案した．
初期のモデル検査システムは，\(10^4\) から \(10^5\) 程度の状態をもつ状態遷移グラフを毎秒 100 状態程度の速度で検証するものだった．
このような制限にもかかわらず，モデル検査は，公開された回路設計における未知の誤りを発見することに成功していた．</p>
<h3 id="_14">モデル検査の複雑さ</h3>
<p>Sistla と Clarke はさまざまな時相論理のモデル検査問題を分析し，特に線形時間論理 LTL に ついては PSPACE 完全であることを示した．
Pnueli と Lichtenstein は LTL 式の検証の複雑さに関すしてさらに分析を行い，複雑さは式の長さに対して指数的（exponential）であるが，状態グラフ全体の大きさに対しては線形的であることを発見し，短い論理式に対しては線形時間モデル検査の複雑さも許容できるかもしれないと主張した．
同じ年に，Fujita は LTL 式を対象と したタブロー（tableau）に基づく検証システムを実装し，ハードウェア検証にどのように利用できるかを示した.</p>
<p>CTL* は，分岐時間と線形時間の演算子の両方を組み合わせた非常に表現力の高い論理である．
この論理に対するモデル検査問題は，最初の議論で PSPACE 完全であることが示されており，一般的な複雑さにおいて LTL のモデル検査問題と同じクラスにあることが証明された．
つまり，CTL* と LTL のモデル検査は，状態グラフの大きさと式の長さの両方に対して同じ複雑さをもっており，モデル検査の複雑さに関しては，線形時間論理のみに限定することに実用上の利点はないということがわかった．</p>
<p>並行システムの検証を目的としたその他の技術も，多くの研究者によって提案されている．
これらのアプローチの多くは，実装だけでなく仕様の記述にもオートマトンを用いており，実装の検証は，その振る舞いが 仕様の振る舞いに適合しているかを判定するために行われる．
実装と仕様の両方に同じ形式のモデルを用いているため，ある段階での実装は，詳細化の次の段階に対する仕様としても利用することができる．
言語包含性の利用は，暗黙的に Kurshan による業績に含まれていたが，最終的には強力な検証器である COSPAN の開発につながった．
Vardi と Wolper は，自動検証のために <script type="math/tex">\omega</script> オートマトン（無限長の語に対するオートマトン）を利用することを最初に提案した．
彼らは，<script type="math/tex">\omega</script> オートマトン間の言語包含性の観点から，線形時間論理に関するモデル検査問題がどのように定式化できるかを示した．
また，観測等価（observational equivalence）や様々な詳細化（refinement）関係 を含んだ，オートマトン間の適合性に関するその他の概念も検討されている．</p>
<h2 id="_15">記号的アルゴリズム</h2>
<h3 id="_16">順序付き二分決定グラフ</h3>
<p>もともとのモデル検査アルゴリズムの実装では，遷移関係は隣接リストを用いて明示的に表現されていた．
プロセス数の少ない並行システムであれば，このアプローチは十分に実用的であった．
しかし，多数の並列要素をもつシステムでは，大域的な状態遷移グラフにおける状態数があまりに多いため，扱うことができなかった．</p>
<p>1987 年秋，当時カーネギーメロン大学の大学院生だった McMillan は，状態遷移グラフに記号的表現（symbolic representation）を使用することで，非常に大規模なシステムを検証できることを発見した．
この新しい表現は，Bryant の順序付き二分決定グラフ（Ordered Binary Decision Diagram, OBDD）に基づくものだった．
OBDD は多くの場合，和積標準形（conjunctive normal form）や積和標準形（disjunctive normal form）よりも大幅にコンパクトな表現となるブール式の標準形であり，非常に効率的な演算アルゴリズムも開発されてきた．
OBDD は，回路やプロトコルによって規定される状態空間の規則性の一部をうまく捉えているため，状態数の極めて大きな システムでも効率的な処理が可能となる．
実際，Clarke と Emerson によるオリジナルの CTL モデル検査アルゴリズムに OBDD 表現を用いることで，\(10^{20}\) を越える状態をもついくつかの例を検証することができた．
それ以降も OBDD ベースの技術にはさまざまな改良がなされており，扱うことのできる状態数は \(10^{120}\) 以上にまで増加している．</p>
<h3 id="_17">記号モデル検査アルゴリズム</h3>
<p>この非明示的な表現は，順序回路やプロトコルのモデル化においては非常に自然である．
それぞれの状態は，回路またはプロトコルに関連付けられた状態変数の集合に対するブール値の割り当てとして符号化される．
したがって遷移関係は，遷移前と遷移後の状態をそれぞれ符号化する二つの変数集合に対するブール式として表現される．
そして，これらの論理式は OBDD として表現される．
OBDD ベースのモデル検査アルゴリズムは，遷移関係から得られる述語変換系（predicate transformer）における不動点（fixpoint）の計算に基づいている．
様々な時相論理演算子ごとに述語変換系が対応しており，時相論理式を満たす状態集合はその不動点として求められる．
そして実装においては，述語変換系と不動点がいずれも OBDD として表現される．
これにより，並行システムの状態グラフを明示的に構築することが避けられる.</p>
<h3 id="smv">SMV</h3>
<p>McMillan が開発したモデル検査システムが SMV（Symbolic Model Verifier）である．
SMV は有限状態の並行システムを階層的に記述する言語（SMV 言語という）をもつ．
SMV 言語で記述されたプログラムは，時相論理で表現された仕様を注釈として付けることができる．
SMVは，SMV 言語によるプログラムから OBDD として表現された遷移系を抽出し，OBDD ベースの探索アルゴリズムを用いて，システムが仕様を満たすかどうかの判定を行う．
遷移系が仕様を満たさない場合，その仕様が偽である理由を示す実行系列を生成する．</p>
<p>印象的な例として，IEEE Futurebus+ 規格のキャッシュコヒーレンスプロトコルの検証が挙げられる．
このプロトコルの開発は 1988 年に開始されたが，それまでの検証の試みはすべて非形式的なものだった．
1992 年の夏，カーネギーメロン大学の研究者たちが SMV 言語でプロトコルの精密なモデルを構築することで，得られた遷移システムがキャッシュコヒーレンスの形式的仕様を満たしているかの検証を試みた．
その結果として，これまで検出されなかった多くのエラーや潜在的なエラーを発見することに成功した．</p>
<p>記号的な技術の威力を示す指標の一つは，対象システムの規模が大きくなるにつれて，検証に必要な CPU 時間がどのように増加するかである．
さまざまな研究を通して，この増加率は回路のコンポーネント数に対して次数の小さな多項式程度であることがわかっている．</p>
<h3 id="obdd">OBDD に基づくその他のアプローチ</h3>
<p>他の多くの研究者も，OBDD が大規模な状態遷移系の表現に利用できることを独自に発見している．
Coudert, Berthet, Madre は，二つの決定性有限オートマトン間の等価性を，積オートマトンの状態空間を幅優先探索することにによって示すアルゴリズムを開発しているが，オートマトンの遷移の表現に OBDD を用いている．
同様のアルゴリズムは Pixley によっても開発されている．
さらに，Bose と Fisher，Pixley，Coudert らを含むいくつかの研究グループが，OBDD を用いたモデル検査アルゴリズムに対する実験を行っている．</p>
<p>その他の関連研究として，Bryant，Seger，Beatty は，制限された線形時間論理におけるモデル検査アルゴリズムを開発した．
仕様は，この論理で記述された事前条件（precondition）と事後条件（postcondition）の組として構成される．
事前条件は回路への入力と 初期状態を制限するために用いられ，事後条件はユーザーが検査したい特性を与えるために用いられる．
この論理における式は次のような形に限定されている．
<script type="math/tex; mode=display">
p_0 \wedge \textbf{X} p_1 \wedge \textbf{X}^2 p_2 \wedge \cdots \wedge \textbf{X}^{n-1} p_{n-1} \wedge \textbf{X}^n p_n
</script>
この文法には，他の多くの時相論理に比べて強い制約が設けられている．
特に，許される唯一の論理演算子は論理積であり，唯一の時相演算子は次の状態（next time）を表す演算子（<script type="math/tex"> \textbf{X} </script>）である．
このように，扱える式のクラスを制限することで，検証を効率化することが可能となる．</p>
<h2 id="_18">半順序削減法</h2>
<h3 id="_19">ソフトウェア検証における問題</h3>
<p>ソフトウェアの検証では，ハードウェアとは異なりモデル検査を行う際にいろいろな問題が発生する．
ソフトウェアはハードウェアと比較してあまり構造化されておらず，また，並行ソフトウェアは通常非同期（asynchronous），つまり大域的に同期されたクロックなしで独立に実行される．
これらの理由から，ソフトウェア検証において状態爆発は特に深刻な問題となる．</p>
<p>近年，ソフトウェア検証の状態爆発問題については，かなりの進歩が見られるが，この問題に対処する最も成功した技術の一つは，半順序削減法（partial order reduction）に基づくものである．
この技術は，並列に実行されるイベントの独立性を利用している．
どの順序で実行されても同じグローバル状態に到達するようなイベントは，互いに独立（independent）であるという．</p>
<h3 id="_20">半順序モデルに基づく状態空間の削減</h3>
<p>並行ソフトウェアを表現する一般的なモデルは交互実行モデル（interleaving model）で，一つの実行におけるすべてのイベントが交互実行系列（interleaving sequence）と呼ばれる線形順序で配置される．
ここで独立したイベントは，互いに任意の順序で実行できるが，ほとんどの論理では独立したイベントを異なる順序で実行する交互実行系列どうしは区別される．
結果として，独立したイベントに対するすべての交互実行が考慮されるため，状態空間も非常に大きくなる．</p>
<p>ここで仮に，仕様が独立したイベントの順序のみ異なる交互実行系列を区別できないのであれば，そのうちの一つのみ解析すれば十分である．
プログラム実行の半順序モデル（partial order model of program execution）では，並列に実行されるイベントは順序付けされず，半順序関係をもつ実行を複数の交互実行系列に対応させることができる．
このモデルではこうした複数の系列を区別しないので，イベントの半順序関係それぞれに対して一つの交互実行系列のみを選択することで，考慮すべき系列の個数を削減することが可能となる．</p>
<h3 id="_21">半順序削減法を用いたアルゴリズム</h3>
<p>独立に実行される遷移の交互実行から，部分集合のみを選択することで状態空間を削減するアイデアは，多くの研究者によって研究されてきた．
このような削減手法を提案した最初の研究者の一人は，Overman である．
しかし，彼は，ループと非決定的選択を含まない，制限された並行モデルのみを考慮していた．
Katz と Peled の証明系は，同様の半順序関係をもつ実行に対応する，交互実行系列の間での同値関係の利用を提案している．
この証明系には，交互実行系列のすべてではなく，選択された一部について証明するための推論規則が含まれている．</p>
<p>いくつかの論文で，半順序削減法を組み込んだモデル検査アルゴリズムが提案されている．
Valmari の stubborn 集合，Godefroid の persistent 集合，Peled の ample 集合は，詳細は異なるが，多くの類似したアイデアを含んでいる．
この教科書では，ample 集合に基づく手法を説明する．
実行の半順序モデルと全順序モデルの関係に関する同様の観察に基づくその他の手法は，McMillan の unfolding technique と Godefroid の sleep 集合 である．</p>
<h2 id="_22">状態爆発へのその他のアプローチ</h2>
<p>記号的表現と半順序削減法により，検証可能なシステムのサイズは大幅に拡大したが，未だに現実のシステムの多くは大きすぎて扱うことができない．
そのため，検証可能なシステムのサイズを拡大するために，記号的手法と組み合わせて利用できる技術を見つけることが重要である．
そのような技術として，部分検証（compositional reasoning），抽象化（abstraction），対称性（symmetry），および帰納法 （induction）の 4 つがある．</p>
<h3 id="_23">部分検証</h3>
<p>一つ目の手法は，複雑な回路やプロトコルのモジュール構造（modular structure）を利用するものである．
多くの有限状態システムは，並列に動作する複数のプロセスから構成される．
このようなシステムの仕様は，しばしば，システムの小さな一部の動作を記述する特性へと分解可能である．
露骨な戦略として，それぞれの局所的な特性を，対応するシステムの一部のみを用いて検証することが考えられる．
もしシステムがそれぞれの局所的な特性を満たすことを示した上で，局所的な特性が全て満たされれば全体的な仕様もそうであると言えるのならば，システム全体も同様に仕様も満たすはずである．</p>
<p>構成要素間の相互依存によって，この単純な部分検証が実行不可能な場合，より複雑な戦略が求められる．
このような場合，ある構成要素の特性を検証する際に，他の構成要素の動作について仮定を設ける必要がある．
この仮定は，他の構成要素の正しさが示された後に解除されなければならない．
この戦略は，仮定・保証証明（assume-guarantee reasoning）と呼ばれる．</p>
<h3 id="_24">抽象化</h3>
<p>二つ目の手法は，抽象化の利用である．
記号的手法を用いることで，自明でないデータ操作を伴うシステムも扱うことが可能となるが，検証の複雑さが大きくなることが多い．
抽象化の利用は，データ要素を含むシステムの仕様は，通常，システムのデータの値に関する極めて単純な関係からなるという観察に基づいている．
例えば，マイクロプロセッサの加算処理の検証では，あるレジスタの値が最終的に他の二つのレジスタの値の合計と等しくなることが要求される場合がある．
このような状況では，抽象化を用いてモデル検査の複雑さを軽減することができる．
通常，抽象化は，システムの実際のデータの値から抽象化されたデータ値の小さな集合への対応付けとして考えられる．
この対応付けを状態と遷移へと拡張することで，対象となるシステムの抽象化を得ることが可能である．
多くの場合，抽象化されたシステムは実際のシステムよりもはるかに小さいため，結果として，抽象化されたレベルでの検証は通常はるかに単純になる．</p>
<h3 id="_25">対称性</h3>
<p>対称性も，状態爆発問題を軽減するために利用できる．
有限状態の並行システムは，複製されたコンポーネントを含むことが多い．
例えば，多くのプロトコルは，何らかの方法で通信する同一のプロセスからなるネットワーク上で動作する．
ハードウェアデバイスは，メモリやレジスタファイルなど，多くの複製された要素を持つ部品を含んでいる．
これらの事実は，システムの縮小されたモデルを得るために利用できる．
システムが対称性をもつことは，それぞれが状態遷移グラフと対応する自明でない順列の集まりが存在することを意味している．
このような集まりは，システムの状態空間における等価関係を定義し，状態空間を縮小するために利用できる．
この縮小されたモデルは，時相論理式で表現された当初のモデルの特性の検証を単純化するために用いられる．</p>
<h3 id="_26">帰納法</h3>
<p>帰納法は，有限状態システムの全ての族（family）に対する自動証明を伴う．
この族は，ハードウェアとソフトウェア双方におけるリアクティブ・システムの設計において頻繁に発生する．
一般的に，回路やプロトコルの設計はパラメータ化されており，システムの無限の族を定義している．
例えば，２ つの整数を加算するように設計された回路は，整数 <script type="math/tex">n</script> の幅をパラメータとしてもつことになるし，バスプロトコルは任意の数のプロセッサに対応するように設計され，パラメータ化された個数のプロセスに対して相互排他プロトコルが与えられる．
ここで，与えられた族のすべてのシステムが何らかの時相論理による特性を満たすことを証明したいとしよう．
一般的にこの問題は決定不能であるが，多くの興味深いケースにおいて，族の任意のメンバーの振る舞いを不変プロセス（invariant process）の形で表すことが可能である．
この不変プロセスを用いて，族のすべてのメンバーの特性を一度に証明することができる．
帰納法は，この不変プロセスが族の適切な代表であることを証明するために用いられる．</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href=".." class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Home
              </div>
            </div>
          </a>
        
        
          <a href="../lec02/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                第2回
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/vendor.7e0ee788.min.js"></script>
      <script src="../assets/javascripts/bundle.b3a72adc.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "..",
          features: [],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_CHTML"></script>
      
    
  </body>
</html>