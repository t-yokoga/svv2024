
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.2.5">
    
    
      
        <title>第13回 抽象化 - システム検証論 (2023)</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2d9f7617.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.e6a45f82.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/earlyaccess/notosansjp.css">
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:600,800">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Murecho&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+1p&family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New&display=swap">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    <script>__md_scope=new URL("..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#13" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="システム検証論 (2023)" class="md-header__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            システム検証論 (2023)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第13回 抽象化
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="システム検証論 (2023)" class="md-nav__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    システム検証論 (2023)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec01/" class="md-nav__link">
        第1回 モデル検査とは
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec02/" class="md-nav__link">
        第2回 クリプキ構造と一階の論理表現
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec03/" class="md-nav__link">
        第3回 ハードウェア・ソフトウェアのモデル化
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec04/" class="md-nav__link">
        第4回 時相論理 CTL*
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec05/" class="md-nav__link">
        第5回 CTL* ベースのその他の時相論理
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec06/" class="md-nav__link">
        第6回 CTL モデル検査
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec07/" class="md-nav__link">
        第7回 不動点計算によるモデル検査アルゴリズム
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec08/" class="md-nav__link">
        第8回 LTL と CTL* のモデル検査
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec09/" class="md-nav__link">
        第9回 二分決定グラフ
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec10/" class="md-nav__link">
        第10回 記号モデル検査
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec11/" class="md-nav__link">
        第11回 命題論理の充足可能性判定
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../lec12/" class="md-nav__link">
        第12回 SAT に基づくモデル検査
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          第13回 抽象化
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        第13回 抽象化
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#131-existential-abstraction" class="md-nav__link">
    13.1 存在量化による抽象化 (Existential Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1 存在量化による抽象化 (Existential Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    定義 13.1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133" class="md-nav__link">
    定理 13.3
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1331" class="md-nav__link">
    系 13.3.1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134" class="md-nav__link">
    定理 13.4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1311-localization-reduction" class="md-nav__link">
    13.1.1 局所化削減 (Localization Reduction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.1 局所化削減 (Localization Reduction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cone-of-influence-reduction" class="md-nav__link">
    Cone of Influence Reduction
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1312-data-abstraction" class="md-nav__link">
    13.1.2 データ抽象化 (Data Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.2 データ抽象化 (Data Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#135" class="md-nav__link">
    例 13.5
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1313-predicate-abstraction" class="md-nav__link">
    13.1.3 述語抽象化 (Predicate Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.3 述語抽象化 (Predicate Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#136" class="md-nav__link">
    例 13.6
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#131-existential-abstraction" class="md-nav__link">
    13.1 存在量化による抽象化 (Existential Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1 存在量化による抽象化 (Existential Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#131" class="md-nav__link">
    定義 13.1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#133" class="md-nav__link">
    定理 13.3
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1331" class="md-nav__link">
    系 13.3.1
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#134" class="md-nav__link">
    定理 13.4
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1311-localization-reduction" class="md-nav__link">
    13.1.1 局所化削減 (Localization Reduction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.1 局所化削減 (Localization Reduction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cone-of-influence-reduction" class="md-nav__link">
    Cone of Influence Reduction
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1312-data-abstraction" class="md-nav__link">
    13.1.2 データ抽象化 (Data Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.2 データ抽象化 (Data Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#135" class="md-nav__link">
    例 13.5
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1313-predicate-abstraction" class="md-nav__link">
    13.1.3 述語抽象化 (Predicate Abstraction)
  </a>
  
    <nav class="md-nav" aria-label="13.1.3 述語抽象化 (Predicate Abstraction)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#136" class="md-nav__link">
    例 13.6
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


<h1 id="13">第13回 抽象化</h1>
<p>この回では，教科書の第13章 "Abstraction" の前半 (13 〜 13.1) について説明します．</p>
<div class="admonition summary">
<p class="admonition-title">概要</p>
<ul>
<li>存在量化による抽象化</li>
<li>局所化削減</li>
<li>データ抽象化</li>
<li>述語抽象化</li>
</ul>
</div>
<p>抽象化は，状態爆発問題を軽減するための最も重要な技術の一つである． 
抽象モデルは，関心のある性質に関係のないと思われるシステムのいくつかの詳細を隠すことによって得られ，通常，完全なモデルよりもはるかに小さくなる．
モデルのサイズが小さくなるため，元のモデルよりも抽象モデルの方が検証しやすくなることが多い．  </p>
<p>抽象化される前のシステムのモデルを具体 (concrete) モデルと呼ぶ． 
抽象化は通常，目的の性質に対して保守的であるように選択される．
つまり，抽象 (abstract) モデル上でその性質が成り立つときはいつでも，具体モデル上でも成り立つ．
ここでは，モデル検査を適用できるように，有限状態モデルを生成する抽象化のみを考える．
本章では上方近似 (over approximation) の抽象化に注目する．
このような抽象化には，具体モデルの各動作の代表が含まれる．
また，具体モデルには対応する動作がないような動作が追加されることもある．
しかし，通常，状態や遷移の数はより少なくなる．
その結果，このような抽象化されたモデルは，モデル検査が容易となる．
さらに，LTL や ACTL の性質，つまり普遍的な経路限定を持つ性質に対しては保守的であることが保証されている．</p>
<p>上方近似の抽象化を構築する最も自然な方法は，具体モデルの状態から抽象モデルの状態への写像を定義し，この写像を遷移に拡張することである．
このようにして，元のシステムをシミュレートし，通常よりはるかに小さい抽象モデルを得ることができる．
この抽象化手法は存在量化による抽象化 (existential abstraction) と呼ばれる．</p>
<p>次のセクションでは，存在量化による抽象化に基づく手法のうち，広く利用され，実際に実現可能な3つの実装を調査する．
局所化削減 (Localization reduction) [330] は，特にハードウェアモデルに適している．
これは，性質に無関係な変数を特定し，モデルから削除することにより，回路を抽象化する．
データ抽象化 (Data abstractions) [134][361] では，個々の状態変数のドメインが抽象化される．
述語抽象化 (Predicate abstraction) [252] では，述語の集合を特定し，その述語の評価で一致する具体状態を合体させる．
述語抽象化とデータ抽象化は，ソフトウェアモデルに最も適している．</p>
<p>上方近似による抽象化は，その性質が抽象モデルにおいて真である場合にのみ結論が得られる．
しかし，その性質が満たされなかった場合，具体モデルにおいてそれが偽であると推論することはできない．
これは，上方近似された抽象モデルにおけるその性質の反例が，具体モデルにおいて対応するものをもたない可能性があるからである．
このような反例を<strong>偽りの</strong> (spurious) 反例または "偽陰性 (false negatives)"と呼ぶ．
したがって，抽象モデルの反例に対応する具体的な (その性質が具体モデルでも本当に反証されることを示すような) 反例があるかどうかを確認しなければならない．
もし，その抽象的な反例が偽りのものだとわかったら，その抽象化の欠点を識別し，<strong>洗練</strong> (refine) しなければならない．
この方法は，<strong>Counterexample-Guided Abstraction Refinement</strong> (CEGAR) と呼ばれる [132]．</p>
<h2 id="131-existential-abstraction">13.1 存在量化による抽象化 (Existential Abstraction)</h2>
<p>まず，明示的に与えられた具体モデルに依存する存在量化による抽象化の正式な定義から始める．
この定義は，抽象化が保守的であることを証明するために使われる．
しかし実際には，完全な具体モデルが大きすぎてメモリに収まらないような状況で，抽象化が必要となる．
そこで，システムの何らかの高水準な記述から直接，抽象モデルを構築することにする．
これについては13.2節で説明する．</p>
<p>具体モデルとしてクリプキ構造を <script type="math/tex"> M = (S, S_{0}, R, AP, L) </script> と書くことを想起してほしい．
その抽象モデルはクリプキ構造 <script type="math/tex"> M = (\widehat{S}, \widehat{S_{0}}, \widehat{R}, \widehat{AP}, \widehat{L}) </script> として定義される．
<script type="math/tex"> \widehat{AP} </script> は <script type="math/tex"> AP </script> と同一となるように選択する．
これまでと同様に，<script type="math/tex">AP</script> (したがって <script type="math/tex">\widehat{AP}</script> も) は，検査された性質 <script type="math/tex"> \varphi </script> に現れるすべての原子命題を含む．</p>
<p>
<script type="math/tex"> \widehat{M} </script> を定義するためには，抽象的な状態の集合 <script type="math/tex"> \widehat{S} </script> を用意する必要がある．
<script type="math/tex"> \widehat{S} </script> の抽象状態のそれぞれは，<script type="math/tex"> S </script> の具体状態の集合を表す．
ここでは，すべての具体状態は一意な抽象状態によって表現されると仮定する．
したがって，2つの異なる抽象状態が表現する状態の集合は互いに素であり，具体状態をその抽象的な代表者へと対応づける<strong>抽象化関数</strong> (抽象化関係ではなく) を以下のように定義することができる：
<script type="math/tex; mode=display">
\alpha : S \rightarrow \widehat{S}
</script>
それぞれの具体状態がいずれかの抽象状態によって表現されることを要求しているため，関数 <script type="math/tex">\alpha</script> は全域写像 (total function) となる．
さらに，抽象化では <script type="math/tex">\widehat{AP}</script> の命題への評価が一致する場合のみ，状態をグループ化するように要求する．
この要件は，<script type="math/tex">\alpha</script> の<strong>適切性</strong> (appropriateness) と呼ばれ，形式的には以下のように定義される．</p>
<h4 id="131">定義 13.1</h4>
<div class="admonition abstract">
<p class="admonition-title">定義 13.1</p>
<p>抽象化関数 <script type="math/tex">\alpha</script> は，<script type="math/tex">\alpha(s) = \alpha(s')</script> となるすべての具体状態の組 <script type="math/tex">s</script> および <script type="math/tex">s'</script> に対して <script type="math/tex">L(s) = L(s')</script> が成り立つとき，かつそのときのみ <script type="math/tex">\widehat{AP}</script> に適切である．</p>
</div>
<p>
<script type="math/tex">\widehat{AP} </script> に対する <script type="math/tex">\alpha</script> の適切性によって，抽象状態のラベル付けを簡単に定義することができる．
つまり，抽象状態 <script type="math/tex">\widehat{S}</script> が <script type="math/tex">\widehat{AP}</script> の原子命題でラベル付けされるのは，それが表す具体状態がその命題でラベル付けされているときである．</p>
<div class="admonition note">
<p class="admonition-title">図13.1：存在量化による抽象化</p>
<p>
<script type="math/tex">M</script> は元のクリプキ構造であり，<script type="math/tex">\widehat{M}</script> は抽象化されたものである．
<script type="math/tex">M</script> の破線は，<script type="math/tex">M</script> の状態がどのように抽象的な状態にクラスタリングされるかを示している．
具体状態と抽象状態は <script type="math/tex">AP = \widehat{AP} = \{p, q\}</script> でラベル付けされている．</p>
</div>
<p><center>
<img src="../img/lec13-fig13_1.pdf" width="360">
<br>
図13.1
</center></p>
<p>図 13.1 に具体モデル <script type="math/tex">M</script> とその抽象モデル <script type="math/tex">\widehat{M}</script> を示す．
<script type="math/tex">M</script> の破線は，<script type="math/tex">S</script> を抽象状態に分割したことを表している．
実際はこれに加えて，抽象モデルにおける遷移と初期状態の集合を定義しなければならない．
上方近似であるため，具体モデルのすべての遷移と初期状態に対応したものが，抽象モデルに存在することが保証される．
存在量化による抽象化では，抽象状態が具体モデルにおける初期状態を表していた場合，それが抽象モデルの初期状態になるよう定義する．
同様に，抽象状態 <script type="math/tex">\widehat{s}</script> から抽象状態 <script type="math/tex">\widehat{s'}</script> への遷移は，具体モデルにおいて <script type="math/tex">\widehat{s}</script> が表す状態から <script type="math/tex">\widehat{s'}</script> が表す状態への遷移がある場合，抽象モデルに存在することになる．
これは形式的には次のように定義される． </p>
<div class="admonition abstract">
<p class="admonition-title">定義 13.2</p>
<p>
<script type="math/tex">M = (S, S_{0}, R, AP, L)</script> を (具体的な) クリプキ構造とし，<script type="math/tex">\widehat{S}</script> を抽象状態の集合，<script type="math/tex">AP = \widehat{AP}</script> を (抽象的な) 原子命題の集合とする．
さらに，<script type="math/tex">\alpha : S \rightarrow \widehat{S}</script> を <script type="math/tex">\widehat{AP}</script> に適切な抽象化関数とする．
以下が成り立つとき，クリプキ構造 <script type="math/tex">\widehat{M} = (\widehat{S}, \widehat{S_{0}}, \widehat{R}, \widehat{AP}, \widehat{L})</script> は <script type="math/tex">\alpha</script> に関する <script type="math/tex">M</script> の <strong>(存在量化による) 抽象化</strong>である．</p>
<ol>
<li>
<script type="math/tex">\exists s (\alpha (s) = \widehat{s} \wedge s \in S_{0})</script> であるとき，<script type="math/tex">\widehat{s} \in S_{0}</script> である；</li>
<li>
<script type="math/tex">\exists s_{1},s_{2} (\alpha (s_{1}) = \widehat{s_{1}} \wedge \alpha (s_{2}) = \widehat{s_{2}} \wedge (s_{1},s_{2}) \in R)</script> であるとき，<script type="math/tex"> (\widehat{s_{1}},\widehat{s_{2}}) \in \widehat{R}</script> である；</li>
<li>
<script type="math/tex">\alpha (s) = \widehat{S}</script> となる <script type="math/tex">s</script> に対して <script type="math/tex"> \widehat{L}(\widehat{s}) = L(s)</script> である．</li>
</ol>
</div>
<p>非形式的には，抽象化 <script type="math/tex">\widehat{M}</script> は <script type="math/tex">M</script> よりも多くの振る舞いをもつ．
これは，模倣前順序関係 (simulation preorder relation) において <script type="math/tex">\widehat{M}</script> が <script type="math/tex">M</script> より大きいことを示す次の定理によって形式化される．</p>
<div class="admonition tip">
<p class="admonition-title">全順序 (total prder)，半順序 (partial order)，前順序 (preorder)</p>
<p>以下の 1 <script type="math/tex">\sim</script> 4 を満たす順序関係を全順序 (total order) といい，
1 <script type="math/tex">\sim</script> 3 を満たす順序関係を半順序 (partial order) といい，
1 <script type="math/tex">\sim</script> 2 を満たす順序関係を前順序 (preorder) という．</p>
<ol>
<li>
<script type="math/tex">a \le a</script> が成り立つ．(反射律)</li>
<li>
<script type="math/tex">a \le b</script> かつ <script type="math/tex">b \le c</script> ならば <script type="math/tex">a \le c</script> である．(推移律)</li>
<li>
<script type="math/tex">a \le b</script> かつ <script type="math/tex">b \le a</script> ならば <script type="math/tex">a = b</script> である．(反対称律)</li>
<li>
<p>
<script type="math/tex">a \le b</script> または <script type="math/tex">b \le a</script> のいずれか必ず成り立つ．(完全律)</p>
</li>
<li>
<p>自然数 <script type="math/tex">a, b \in \mathbb{N}</script> に対して，大小関係 <script type="math/tex">a \le b</script> は前順序である．</p>
</li>
<li>
<script type="math/tex">S</script> の冪集合の要素 <script type="math/tex">a, b \in 2^{S}</script> に対して，包含関係 <script type="math/tex">a \subseteq b</script> は半順序である．(包含関係が成り立たない元がある)</li>
<li>
<script type="math/tex">S</script> の冪集合の要素 <script type="math/tex">a, b \in 2^{S}</script> に対して，要素数の大小関係 <script type="math/tex">a \preceq b \Leftrightarrow |a| \le |b|</script> は前順序である．</li>
</ol>
</div>
<p>定理 11.9 から，<script type="math/tex">\widehat{M}</script> について成り立つすべての ACTL* 式は，<script type="math/tex">M</script> についても同様に成り立つ．</p>
<h4 id="133">定理 13.3</h4>
<div class="admonition abstract">
<p class="admonition-title">定理 13.3</p>
<p>
<script type="math/tex">M</script> をクリプキ構造とし，<script type="math/tex">\widehat{M}</script> を <script type="math/tex">M</script> の抽象化とする．
このとき <script type="math/tex">M \preceq \widehat{M}</script> となる．</p>
</div>
<div class="admonition note">
<p class="admonition-title">証明</p>
<p>
<script type="math/tex">\widehat{M}</script> を構成するのに使用した抽象化関数を <script type="math/tex">\alpha</script> とする．
<script type="math/tex">M</script> と <script type="math/tex">\widehat{M}</script> の間の関係 <script type="math/tex">H</script> を与え，それが模倣関係 (simulation relation) であることを示す．
すべての <script type="math/tex">s \in S</script> および <script type="math/tex">\widehat{s} \in \widehat{S}</script> に対して以下のように定義する．
<script type="math/tex; mode=display">
(s, \widehat{s}) \in H \text{ iff } \alpha(S) = \widehat{s}
</script>
まず，すべての <script type="math/tex">s_{0} \in S_{0}</script> に対して，<script type="math/tex">(s_{0}, \widehat{s_{0}}) \in H</script> となるような <script type="math/tex">\widehat{s_{0}} \in \widehat{S_{0}}</script> が存在することを示す．
存在量化による抽象化の定義により，任意の初期状態 <script type="math/tex">s_{0}</script> に対して <script type="math/tex">\alpha(s_{0})</script> は <script type="math/tex">\widehat{M}</script> の初期状態である．
<script type="math/tex">H</script> の定義により，<script type="math/tex">(s_{0}, \alpha(s_{0})) \in H</script> となる．</p>
<p>
<script type="math/tex">(s, \widehat{s}) \in H </script>と仮定する．
まず，この 2 つの状態は，<script type="math/tex">\widehat{AP}</script> のラベル付けについて一致していることに注目してほしい．
したがって <script type="math/tex">L(s) \cap \widehat{AP} = \widehat{L}(\widehat{s})</script> となる．</p>
<p>
<script type="math/tex">(s, t) \in R</script> とする．
<script type="math/tex">(\alpha(s), \alpha(t)) \in \widehat{R}</script> であると示さなければならないが，これは存在量化による抽象化の定義から直ちに導かれる．</p>
</div>
<p>次の系は定理 13.3 と定理 11.9 の直接の帰結であり，ここでの抽象化における重要な特性である．</p>
<h4 id="1331">系 13.3.1</h4>
<div class="admonition abstract">
<p class="admonition-title">系 13.3.1</p>
<p>
<script type="math/tex">AP</script> 上のすべての ACTL* 式 <script type="math/tex">\varphi</script> に対して，<script type="math/tex">\widehat{M} \models \varphi</script> であれば <script type="math/tex">M \models \varphi</script> となる．</p>
</div>
<p>系 13.3.1 は，<script type="math/tex">\widehat{M} \models \varphi</script> の場合，つまり抽象モデル上で性質 <script type="math/tex"> \varphi </script> が真となる場合にのみ，<script type="math/tex">M</script> に関する情報を提供する．
<script type="math/tex">\widehat{M} \lnot \models \varphi</script> となるとき，<script type="math/tex">M</script> に関する情報は推論できない．
(この結論は，検証された特性が ACTL* にあることを仮定しているので，<script type="math/tex">\widehat{M} \models \lnot \varphi</script> としてこの系を導くことは不可能である．)
このように，<script type="math/tex">M</script> は <script type="math/tex">\widehat{M}</script> よりも多くの ACTL* 特性を証明することができ，抽象化によって特性 <script type="math/tex">\varphi</script> を検証できるかどうかは抽象化関数 <script type="math/tex">\alpha</script> の選択に依存する．
抽象化が粗すぎる場合，つまりモデルの詳細を抽象化しすぎた場合，モデル検査器は (非常に迅速に) <script type="math/tex">\widehat{M} \models \varphi</script> と答えるかもしれない．
一方，抽象度が高すぎると (極端な話，<script type="math/tex">\alpha</script> は単なる恒等関数であってもよい)，抽象モデルが大きくなりすぎて検証ができなくなる．
13.3.2 節では，抽象化の中に徐々に詳細を追加していくことができる CEGAR のアプローチを示す．</p>
<p>もう一度定義 13.2 を見返して，1. および 2. の項目で <strong>であるとき (if)</strong> を使ったことに注意してほしい．
その結果，抽象モデル <script type="math/tex"> \widehat{M} </script> は一意に決まらない．
なぜなら，抽象モデルに対して，具体モデルに対応関係をもたない初期状態や遷移をもつことを許容しているからである．
上述の定義で <strong>であるとき (if)</strong> を <strong>であるときかつそのときのみ (if and only if)</strong> に置き換えると，<script type="math/tex">\alpha</script> に関して，<script type="math/tex">M</script> の<strong>最も精密な (most precise)</strong> 抽象モデルを得ることができる．
この抽象モデルを <script type="math/tex">\widehat{M_{p}}</script> と表記する．
任意の抽象モデル <script type="math/tex">\widehat{M}</script> は，最も精密な抽象モデル <script type="math/tex">\widehat{M_{p}}</script> を模倣 (simulate) する．
したがって，次の定理が成り立つ．</p>
<h4 id="134">定理 13.4</h4>
<div class="admonition abstract">
<p class="admonition-title">定理 13.4</p>
<p>モデル <script type="math/tex">M</script> と抽象化関数 <script type="math/tex">\alpha</script> が与えられたとき，<script type="math/tex">\widehat{M}</script> を <script type="math/tex">M</script> の抽象化，<script type="math/tex">\widehat{M_{p}}</script> をその最も精密な抽象化とする (いずれも <script type="math/tex"> \alpha </script> に関して)．このとき，<script type="math/tex">M \preceq \widehat{M_{p}} \preceq \widehat{M}</script> となる．</p>
</div>
<div class="admonition note">
<p class="admonition-title">証明</p>
<p>明らかに，<script type="math/tex">M \preceq \widehat{M_{p}}</script> は定理 13.3 の特別な場合として成立する．
<script type="math/tex">\widehat{M_{p}} \preceq \widehat{M}</script> を示すため，<script type="math/tex">\widehat{S}</script> 上の恒等関数を <script type="math/tex">H</script> とする．
定義より，<script type="math/tex">\widehat{M}</script> と <script type="math/tex">\widehat{M_{p}}</script> は同じ抽象状態の集合に対して定義される．
さらに，<script type="math/tex">\widehat{M}</script> は <script type="math/tex">\widehat{M_{p}}</script> より多くの初期状態と遷移をもつ．
したがって，<script type="math/tex">H</script> は <script type="math/tex">\widehat{M_{p}}</script> と <script type="math/tex">\widehat{M}</script> の間の模倣関係である．</p>
</div>
<p>最も正確な抽象化は，一般に，具体モデルについてより多くの特性を証明することを可能にするが，計算コストも高くなる．</p>
<p>次節では，いくつかの一般的な抽象化の定義方法について説明する．
これらはすべて存在量化による抽象化の実例である．
これらは，抽象状態 <script type="math/tex">\widehat{S}</script> の選択，原子命題の集合 <script type="math/tex">\widehat{AP} = AP</script>，および抽象化関数 <script type="math/tex">\alpha</script> の定義が互いに異なる．
定義 13.2 が <script type="math/tex">\widehat{S_{0}}</script>, <script type="math/tex">\widehat{R}</script>, <script type="math/tex">\widehat{L}</script> を提供していることから，これで十分である．</p>
<h3 id="1311-localization-reduction">13.1.1 局所化削減 (Localization Reduction)</h3>
<p>具体的なモデルの記述には，第 3 章で定義されたシステムの記号表現を用いる．
<script type="math/tex">\varphi</script> を変数の集合 <script type="math/tex">V = \{v_{1},\ldots,v_{n}\}</script> 上のシステムとし，<script type="math/tex">D_{v}</script> を <script type="math/tex">v \in V</script> の領域とする．
<script type="math/tex">S = D_{v_1} \times \ldots \times D_{v_n}</script> とする <script type="math/tex">\varphi</script> の具体モデルを <script type="math/tex">M</script> とする．
局所化削減 (localization reduction) [330] は，変数を<strong>可視 (visible) </strong>変数と <strong>不可視 (invisible) </strong>変数に分割することに基づく抽象化技法である．
これはハードウェアのモデル検査に広く用いられている．</p>
<p>可視変数 (<script type="math/tex">\mathcal{V}</script> と記す) は，検査された特性 <script type="math/tex">\varphi</script> にとって重要であると考えられるため，抽象モデルに保持される．
それ以外の<strong>不可視 (invisible) </strong>と呼ばれる変数は，<script type="math/tex">\varphi</script> の検査に無関係であると考えられる．
理想的には，変数の小さな部分集合のみが可視となる．
可視変数の集合は常に原子命題 <script type="math/tex">\widehat{AP}</script> に現れる変数を含む．</p>
<p>具体状態とは，<script type="math/tex">V</script> の全変数への付値であることを思い出して欲しい．
ここで，抽象状態 <script type="math/tex">\widehat{s} \in \widehat{S}</script> を可視変数への付値であると定義する．
<script type="math/tex"> \mathcal{V} = \{u_{1},\ldots,u_{q}\} \subseteq V</script> を可視変数の集合とする．
そうすると，抽象状態の集合は <script type="math/tex">\widehat{S} = D_{u_1} \times \ldots \times D_{u_q}</script> となる．</p>
<p>具体状態 <script type="math/tex">s</script> が与えられたとき，対応する抽象状態 <script type="math/tex">\alpha (s)</script> は，以下のように <script type="math/tex">s</script> を <script type="math/tex">\mathcal{V} </script> の変数に射影したものである：
<script type="math/tex; mode=display">
\alpha (s) = (s(u_{1}),s(u_{2}),\ldots,s(u_{q})) 
</script>
抽象状態は，可視変数の値に関して矛盾しないようなすべての具体状態を表す．</p>
<p>
<script type="math/tex">\mathcal{V}</script> は <script type="math/tex">\widehat{AP}</script> に現れるすべての変数を含むため，同じ抽象状態に対応付けされるすべての具体状態において，<script type="math/tex">\widehat{AP}</script> の付値は同じとなる．
したがって，<script type="math/tex">\alpha</script> は <script type="math/tex">\widehat{AP}</script> に適切である．
<script type="math/tex">\alpha</script> が定義されると，<script type="math/tex">\widehat{M}</script> の残りの構成要素は定義 13.2 から導かれる．</p>
<h4 id="cone-of-influence-reduction">Cone of Influence Reduction</h4>
<p>次に，保守的 (conservative) な可視変数の集合の選択方法を紹介する．
ここで，第 3 章 3.3 節で示したハードウェアのモデル化に関するいくつかの定義を再掲する．
各変数 <script type="math/tex">v \in V</script> は，次状態関数 <script type="math/tex">f_{v}(V)</script> によって関連付けられると仮定する．
一般に，<script type="math/tex">f_{v}</script> は <script type="math/tex">V</script> の部分集合にのみ依存する．
式 <script type="math/tex">\varphi</script> の Cone of Influence (COI) [136] は，以下のように帰納的に定義される．
まず，<script type="math/tex">\varphi</script> のすべての変数を含む．
さらに，<script type="math/tex">v</script> が COI に含まれる場合，<script type="math/tex">f_{v}</script> が依存するすべての変数も同様に COI に含まれる．</p>
<p>
<script type="math/tex">\varphi</script> の COI を可視変数の集合とすることで，<script type="math/tex">\varphi</script> に関して具体モデルと<strong>等価 (equivalent)</strong> な抽象モデルが得られる．
つまり，具体モデルが <script type="math/tex">\varphi</script> を満たす場合のみ，かつそのときのみ抽象モデルも <script type="math/tex">\varphi</script> を満たすことになる．
その結果，抽象モデルにおける <script type="math/tex">\varphi</script> への反駁は，具体モデルにおける反駁に帰着する．
しかしながら，多くの場合 COI が非常に大きくなってしまい，このような選択は現実的でない．</p>
<p>13.2.2 節の例 13.10 は，Localization Reduction がハードウェアに最も適している理由を示している．
ブール変数だけを考える場合，一部の変数の挙動は完全に不定 (いわば，外部からの入力のように振る舞う) とし，他の変数の挙動は完全に指定することがしばしば有用である． 
ソフトウェアの場合，変数のドメインが非常に大きいか，あるいは無限大になると，変数の振る舞いを完全にモデルに含めることが現実的ではないかもしれない．</p>
<p>原理的に，Localization Reduction は無限領域のすべての変数を不可視にすることで，無限状態モデルを有限状態抽象モデルに抽象化するために用いられる．
しかし，結果として得られる抽象化では，これらの変数に関するいかなる性質も証明することはできない．
次節では，無限領域を有限領域に写像することで，無限領域の変数を証明できる抽象化手法を示す．</p>
<h3 id="1312-data-abstraction">13.1.2 データ抽象化 (Data Abstraction)</h3>
<p>具体モデルは前節と同様に与えられると仮定する．
ここでは，抽象領域がシステムの各変数に対して個別に選択されるような，特別な種類のデータ抽象化 [134][361] について説明する．
通常，抽象領域は有限であり，変数の元の領域よりかなり小さい．
各変数 <script type="math/tex">v</script> に対して，<script type="math/tex">v</script> の具体領域を <script type="math/tex">v</script> の抽象領域へと対応づける一つの抽象化関数 <script type="math/tex">\alpha_{v}</script> を定義する．
具体状態に対する抽象化関数は，個々の変数に対する抽象化関数から構成される．</p>
<p>
<script type="math/tex">D_{v}</script> は変数 <script type="math/tex">v</script> の具体領域を表すことを思い出してほしい．
<script type="math/tex">v</script> の抽象領域を <script type="math/tex">\widehat{D_{v}}</script>，<script type="math/tex">v</script> の抽象化関数を <script type="math/tex">\alpha_{v} : D_{v} \rightarrow \widehat{D_{v}}</script> とする．
このとき，抽象状態空間は以下によって定義される．
<script type="math/tex; mode=display">
\widehat{S} = \widehat{D_{v_{1}}} \times \ldots \times \widehat{D_{v_{n}}}
</script>
具体状態 <script type="math/tex">s = (d_{1},\ldots,d_{n})</script> に対して，抽象化関数 <script type="math/tex">\alpha</script> は次のように定義される．
<script type="math/tex; mode=display">
\alpha((d_{1}, \ldots, d_{n})) = (\alpha_{v_{1}}(d_{1}), \ldots, \alpha_{v_{n}}(d_{n}))
</script>
</p>
<p>データ抽象化は，変数が別々に抽象化されるため，完全な具体状態上に定義される抽象化よりも計算が簡単な場合が多い．</p>
<h4 id="135">例 13.5</h4>
<div class="admonition example">
<p class="admonition-title">例 13.5</p>
<p>
<script type="math/tex">\mathcal{P}</script> を整数上の変数 <script type="math/tex">x</script> と <script type="math/tex">y</script> をもつプログラムとする．
<script type="math/tex">AP = \widehat{AP} = \{x < 0, x = 0, even(y)\}</script> とする．
このとき，
<script type="math/tex; mode=display">
\widehat{D_{x}} = \{a_{-}, a_{0}, a_{+}\}
</script>
および
<script type="math/tex; mode=display">
\alpha_{x}(d) = \left\{ \begin{array}{lcr}
a_{+} & \text{ if } & d > 0 \\
a_{0} & \text{ if } & d = 0 \\
a_{-} & \text{ if } & d < 0 
\end{array} \right .
</script>
であり，
<script type="math/tex; mode=display">
\widehat{D_{y}} = \{a_{even}, a_{odd}\}
</script>
および
<script type="math/tex; mode=display">
\alpha_{y}(d) = \left\{ \begin{array}{lcr}
a_{even} & \text{ if } & even(|d|) \\
a_{odd}  & \text{ if } & odd(|d|) 
\end{array} \right .
</script>
<br />
であるように選ぶことができる．
<script type="math/tex">s</script> および <script type="math/tex">s'</script> を，<script type="math/tex">s(x) = s(y) = 2</script>，<script type="math/tex">s'(x) = -7</script> および <script type="math/tex">s'(y) = 5</script> となる 2 つのプログラム状態とする．
このとき，<script type="math/tex">\alpha(s) = (a_{+}, a_{even})</script> かつ <script type="math/tex">\alpha(s') = (a_{-}, a_{odd}) </script> となる．
具体状態と抽象状態を図 13.2 に示す．
結果として得られる <script type="math/tex">\alpha</script> は <script type="math/tex">\widehat{AP} </script> に対して適切であることに注意してほしい．</p>
</div>
<p><center>
<img src="../img/lec13-fig13_2.pdf" width="360">
<br>
図13.2
</center></p>
<p>各変数を単独で抽象化した場合，データ抽象化の適切性要件を満たすことは必ずしも容易ではない． 
もし，<script type="math/tex">\widehat{AP}</script> の各原子命題が 1 つの変数だけを参照していれば，その変数に対してしかるべき抽象化領域を定義することは常に可能である．
抽象領域 <script type="math/tex">\widehat{D_{v}}</script> は，<script type="math/tex">v</script> を参照する原子命題によって引き起こされる分割を用いて定義できる．
この結果，例 13.6 に示すような適切な抽象化関数 <script type="math/tex">\alpha</script> が得られる．</p>
<p>一方，<script type="math/tex">AP</script> に 2 つ以上の変数を参照する原子命題がある場合，適切な抽象化関数をもたらす個々の変数の抽象領域を見つけることはできないかもしれない．
これには，複数の変数をまとめて抽象化したものを利用することで対応できる．
このような抽象化は <strong>relational abstraction (関係的抽象化)</strong> [390][132] と呼ばれる．
pata abstraction のような抽象化を <strong>non-relational (非関係的)</strong> という．
よく知られた関係性抽象化の例は <strong>octagon abstract domain (八角形抽象領域)</strong> [391] であり，<script type="math/tex">x</script> と <script type="math/tex">y</script> を変数とし，<script type="math/tex">c</script> を定数とする <script type="math/tex">\pm{x} \pm{y} \leq c</script> という形の制約を表現することができる．
もう一つの広く使われている関係的抽象化は，次で述べる predicate abstraction (述語抽象化) である．</p>
<h3 id="1313-predicate-abstraction">13.1.3 述語抽象化 (Predicate Abstraction)</h3>
<p>述語抽象化 [252] は述語 <script type="math/tex">{P_{1}, \ldots, P_{k}}</script> の集合に基づく．ここで，各 <script type="math/tex">P_{i}</script> は具体状態の部分集合である．
通常，述語はシステムの変数上の原子的な一階論理式によって与えられる．
ここでは，論理式とそれを満たす状態の集合を等価に考える．</p>
<p>各述語 <script type="math/tex">P_{j}</script> はブール型状態変数 <script type="math/tex"> B_{j} </script> と関連付けられている．
これらのブール変数は抽象状態空間を定義する．
すなわち，抽象状態 <script type="math/tex">\widehat{s} \in \{0,1\}^{k}</script> は <script type="math/tex">{B_{1}, \ldots, B_{k}}</script> への付値である．</p>
<p>述語は，具体状態空間を抽象状態空間に対応づける抽象化関数 <script type="math/tex"> \alpha </script> を定義する．
具体状態 <script type="math/tex">s</script> は，状態 <script type="math/tex">s</script> で評価されたときに <script type="math/tex">B_{i}</script> の値が述語 <script type="math/tex">P_{i}</script> の値と一致する抽象状態へ対応づけられる：
<script type="math/tex; mode=display">
\alpha(s) = (P_{1}(s), \ldots, P_{k}(s))
</script>
抽象状態 <script type="math/tex">\widehat{s}</script> における <script type="math/tex">B_{i}</script> の真理値を <script type="math/tex">\widehat{s}(B_{i}) </script> と記す．</p>
<p>適切性の要件を満たすため，<script type="math/tex">\widehat{AP}</script> のすべての原子命題 (したがって，特性 <script type="math/tex">\varphi</script> 内のすべての原子命題) は，述語の集合に含まれる必要がある．
このとき，抽象状態 <script type="math/tex">\widehat{s}</script> は <script type="math/tex">\widehat{s}(B_{i})</script> である場合，かつそのときのみ <script type="math/tex">P_{i} \in \widehat{AP}</script> でラベル付けされることを見てほしい．</p>
<p>述語抽象化はプログラムに対してよく適用される．
この場合の最適化については，第 14 章で詳しく説明する．</p>
<h4 id="136">例 13.6</h4>
<div class="admonition example">
<p class="admonition-title">例 13.6</p>
<p>これまでに定義された概念のいくつかを，簡単な例で説明する．
自然数上の変数 <script type="math/tex">x</script> と <script type="math/tex">y</script> と，単一の遷移 <script type="math/tex">x:= x + 1</script> をもつプログラム <script type="math/tex">\mathcal{P}</script> を考えよう．
<script type="math/tex">AP = \widehat{AP} = \{P_{1}, P_{2}, P_{3}\}</script> とし，<script type="math/tex">P_{1} \Leftrightarrow (x \leq 1)</script>，<script type="math/tex">P_{2} \Leftrightarrow (x > y)</script> および <script type="math/tex">P_{3} \Leftrightarrow (y = 2)</script> とする．</p>
<p>
<script type="math/tex">s(x) = s(y) = 0</script>，<script type="math/tex">t(x) = 1</script> および <script type="math/tex">t(y) = 2</script> となる 2 つの具体状態 <script type="math/tex">s</script> および <script type="math/tex">t</script> を考える．
このとき，<script type="math/tex">L(s) = \{P_{1}\}</script> および <script type="math/tex">L(t) = \{P_{1}, P_{3}\}</script> となる．</p>
<p>抽象状態は，ブール変数 <script type="math/tex">B_{1}, B_{2}, B_{3} </script> への付値で定義される．
したがって，<script type="math/tex">\widehat{S} = \{0,1\}^{3}</script> となる．
抽象化関数 <script type="math/tex">\alpha</script> は，<script type="math/tex">s</script> と <script type="math/tex">t</script> を以下の抽象状態へと対応づける：
<script type="math/tex; mode=display">
\alpha(s) = (1,0,0) \text{ and } \alpha(t) = (1,0,1)
</script>
なお，<script type="math/tex">\widehat{L}((1,0,0)) = L(s) = \{P_{1}\}</script> であり，<script type="math/tex">\widehat{L}((1,0,1)) = L(t) = \{P_{1}, P_{3}\}</script> である．</p>
</div>

              
            </article>
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../lec12/" class="md-footer__link md-footer__link--prev" aria-label="Previous: 第12回 SAT に基づくモデル検査" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              第12回 SAT に基づくモデル検査
            </div>
          </div>
        </a>
      
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.annotate"], "search": "../assets/javascripts/workers/search.bd0b6b67.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.467223ff.min.js"></script>
      
        <script src="../js/extra.js"></script>
      
        <script src="../js/config.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_CHTML"></script>
      
    
  </body>
</html>