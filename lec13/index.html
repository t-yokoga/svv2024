
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../lec12/">
      
      
        <link rel="next" href="../lec14/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.26">
    
    
      
        <title>第13回 非有界モデル検査 - システム検証論 (2023)</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/earlyaccess/notosansjp.css">
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:600,800">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Murecho&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+1p&family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New&display=swap">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#13" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="システム検証論 (2023)" class="md-header__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            システム検証論 (2023)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第13回 非有界モデル検査
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="システム検証論 (2023)" class="md-nav__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    システム検証論 (2023)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec01/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1回 モデル検査とは
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec02/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2回 クリプキ構造と一階の論理表現
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec03/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3回 ハードウェア・ソフトウェアのモデル化
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec04/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4回 時相論理 CTL*
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec05/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5回 CTL* ベースのその他の時相論理
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec06/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6回 CTL モデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec07/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7回 不動点計算によるモデル検査アルゴリズム
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec08/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第8回 LTL と CTL* のモデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec09/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第9回 二分決定グラフ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec10/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第10回 記号モデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec11/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第11回 命題論理の充足可能性判定
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec12/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第12回 SATに基づくモデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    第13回 非有界モデル検査
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    第13回 非有界モデル検査
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    <span class="md-ellipsis">
      10.3 帰納不変式を用いたモデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.3 帰納不変式を用いたモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#105" class="md-nav__link">
    <span class="md-ellipsis">
      定義 10.5 (帰納不変式)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#104-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4 Craig 補間を用いたモデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4 Craig 補間を用いたモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1041-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.1 Craig 補間
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.1 Craig 補間">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#106-craig" class="md-nav__link">
    <span class="md-ellipsis">
      定理 10.6 (Craig の補間定理)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1042-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.2 導出証明を用いた Craig 補間の生成
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.2 導出証明を用いた Craig 補間の生成">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#107" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#108-mcmillan" class="md-nav__link">
    <span class="md-ellipsis">
      定義 10.8 (McMillan の補間系)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#109" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.9
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1043-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.3 Craig 補間を用いた到達可能性検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.3 Craig 補間を用いた到達可能性検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1010" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.10
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1044" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.4 完全性についての議論
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#105-pdr" class="md-nav__link">
    <span class="md-ellipsis">
      10.5 特性指向到達可能性検査 (PDR)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.5 特性指向到達可能性検査 (PDR)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1051" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.1 概要
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1052" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.2 主な手続き
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1053" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.3 フロンティアの拡張
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1054" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.4 完全性についての議論
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.5.4 完全性についての議論">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      健全性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      停止性
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      書誌情報
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec14/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第14回 抽象化による検査コストの削減
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec15/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第15回 反例主導型抽象詳細化 (CEGAR)
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    <span class="md-ellipsis">
      10.3 帰納不変式を用いたモデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.3 帰納不変式を用いたモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#105" class="md-nav__link">
    <span class="md-ellipsis">
      定義 10.5 (帰納不変式)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#104-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4 Craig 補間を用いたモデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4 Craig 補間を用いたモデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1041-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.1 Craig 補間
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.1 Craig 補間">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#106-craig" class="md-nav__link">
    <span class="md-ellipsis">
      定理 10.6 (Craig の補間定理)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1042-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.2 導出証明を用いた Craig 補間の生成
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.2 導出証明を用いた Craig 補間の生成">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#107" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.7
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#108-mcmillan" class="md-nav__link">
    <span class="md-ellipsis">
      定義 10.8 (McMillan の補間系)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#109" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.9
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1043-craig" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.3 Craig 補間を用いた到達可能性検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.4.3 Craig 補間を用いた到達可能性検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1010" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.10
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1044" class="md-nav__link">
    <span class="md-ellipsis">
      10.4.4 完全性についての議論
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#105-pdr" class="md-nav__link">
    <span class="md-ellipsis">
      10.5 特性指向到達可能性検査 (PDR)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.5 特性指向到達可能性検査 (PDR)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1051" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.1 概要
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1052" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.2 主な手続き
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1053" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.3 フロンティアの拡張
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1054" class="md-nav__link">
    <span class="md-ellipsis">
      10.5.4 完全性についての議論
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.5.4 完全性についての議論">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      健全性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      停止性
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      書誌情報
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="13">第13回 非有界モデル検査</h1>
<p>この回では，教科書の第10章 "SAT-based Model Checking" の後半 (10.3 〜 10.5) について説明します．</p>
<div class="admonition summary">
<p class="admonition-title">概要</p>
<ul>
<li>帰納不変式を用いた検証</li>
<li>Craig 補間を用いた非有界モデル検査</li>
<li>特性指向到達可能性解析 (PDR)</li>
</ul>
</div>
<h2 id="103">10.3 帰納不変式を用いたモデル検査</h2>
<p>前節で，帰納的推論が<script type="math/tex">\textbf{AG}p</script>という形の特性を証明するために適用できることを見てきた．
しかし，すべての真となる特性が 1-帰納的でもあるとは限らず，k-帰納法は時として <script type="math/tex">k</script> に非常に大きな値を必要とすることがあることも見てきた．
この章の残りの部分では，帰納不変式であり <script type="math/tex">p</script> を推論する述語 <script type="math/tex">I</script> を自動的に生成することを目的とした，SAT に基づく技術を紹介する．</p>
<p>遷移システムに対する帰納不変式の形式的定義を与えるために，まず，5.3.2 節で導入した<strong>像計算</strong> (image computation) と<strong>不動点</strong> (fixedpoints) を思い出そう．
ここで，モデル <script type="math/tex">M</script> が与えられる．
状態の集合 <script type="math/tex">Q</script> の <strong>像</strong> (post image) は，<script type="math/tex">Q</script> から 1 回の遷移で到達可能な状態の集合であることを思い出してほしい．
この集合について，以下のように <script type="math/tex">post\text{-}image(Q)</script> と表記する．
<script type="math/tex; mode=display">
post\text{-}image(Q) = \{s' \mid \exists s \in Q.R(s, s')\}
</script>
</p>
<p>5.3.2節では，像演算子を反復的に適用して，到達可能な状態の集合を計算できることを示している．
この手法は到達可能性解析と呼ばれる．
到達可能性解析では，状態の集合 <script type="math/tex">Q</script> を，初期状態から到達可能であることが既知の状態を含むよう維持する．
初期状態の集合から始めて，<script type="math/tex">Q</script> に新しい状態が追加されなくなるまで像演算子を適用する．
つまり，不動点に到達したことになる．
到達可能性解析を利用して，<script type="math/tex">Q</script> の状態が <script type="math/tex">p</script> でラベル付けされているかどうかを確認することで，<script type="math/tex">\textbf{AG}p</script> という形の特性を決定することができる．
<script type="math/tex">Q</script> のすべての状態が <script type="math/tex">p</script> を満たすならば，<script type="math/tex">M \models \textbf{AG}p</script> と結論づけることができる．</p>
<p>ここで，帰納不変式とは何かを形式的に捉えることができる．</p>
<h4 id="105">定義 10.5 (帰納不変式)</h4>
<div class="admonition abstract">
<p class="admonition-title">定義 10.5 (帰納不変式)</p>
<p>
<script type="math/tex">M</script> をモデルとする．
以下の条件が成立するとき，集合 <script type="math/tex">I \subseteq S</script> は特性 <script type="math/tex">\textbf{AG}p</script> に対する<strong>帰納不変式</strong> (inductive invariant) であるという．</p>
<ol>
<li>集合 <script type="math/tex">I</script> は，初期状態の集合を含まなければならない．すなわち，<script type="math/tex">S_0 \subseteq I</script> である．</li>
<li>集合 <script type="math/tex">I</script> は，<script type="math/tex">\neg p</script> でラベル付けされた状態を含んではならない．すなわち，<script type="math/tex">\forall s \in I.s \models p</script> である．</li>
<li>集合 <script type="math/tex">I</script> は，遷移関係のもとで閉じていなければならない．すなわち，<script type="math/tex">post\text{-}image(I) \subseteq I</script> が満たされる． </li>
</ol>
</div>
<p>
<script type="math/tex">\textbf{AG} p</script>に対する帰納不変式の存在が，<script type="math/tex">\textbf{AG} p</script> が <script type="math/tex">M</script> で成立することを導くことは，容易に理解できる．
次節では，アルゴリズム的に帰納不変式を得るためのクレイグ補間の利用について説明する．</p>
<h2 id="104-craig">10.4 Craig 補間を用いたモデル検査</h2>
<h3 id="1041-craig">10.4.1 Craig 補間</h3>
<p><strong>Craig 補間</strong> (Craig interpolant) によるモデル検査は，1957年に Craig が提案した補間と呼ばれる論理的概念を用いた手法である <sup id="fnref:164"><a class="footnote-ref" href="#fn:164">1</a></sup>．
<script type="math/tex">A</script> と <script type="math/tex">B</script> を2つの一階論理式とする．
<script type="math/tex">A</script> と <script type="math/tex">B</script> に対する補間 <script type="math/tex">I</script> は，以下を満たす一階論理式で，かつ <script type="math/tex">I</script> の全ての変数が <script type="math/tex">A</script> と <script type="math/tex">B</script> の両方に現れるものをいう．
<script type="math/tex; mode=display">
A \Rightarrow I \text{ and } I \Rightarrow \neg B
</script>
<script type="math/tex">A \wedge B</script> が充足不能となる論理式の組 <script type="math/tex">A</script> と <script type="math/tex">B</script> は，<strong>矛盾</strong> (inconsistent) しているという．
Craig の定理は，任意の矛盾した 2 つの一階論理式 <script type="math/tex">A</script> および <script type="math/tex">B</script> に対して，補間が存在することを示している．
アルゴリズム検証の文脈においては，この定理は通常，以下の等価な形式で述べられる．</p>
<h4 id="106-craig">定理 10.6 (Craig の補間定理)</h4>
<div class="admonition abstract">
<p class="admonition-title">定理 10.6 (Craig の補間定理)</p>
<p>矛盾する一階論理式の組 <script type="math/tex">A</script> と <script type="math/tex">B</script> が与えられたとき，次のような補間 <script type="math/tex">I</script> が存在する．</p>
<ol>
<li>
<script type="math/tex">A</script> ならば <script type="math/tex">I</script> である．</li>
<li>
<script type="math/tex">I</script> は <script type="math/tex">B</script> と矛盾する．</li>
<li>
<script type="math/tex">I</script> は <script type="math/tex">A</script> と <script type="math/tex">B</script> の両方に含まれる記号のみを用いている．</li>
</ol>
</div>
<p>一階論理の多くの部分論理に対して，<script type="math/tex">A \wedge B</script> が充足不能であることを示す証明から Craig 補間を計算するアルゴリズム技術が存在している．
ここでは，導出証明と命題論理の特殊な場合について Craig 補間を計算するための手法を示す．</p>
<h3 id="1042-craig">10.4.2 導出証明を用いた Craig 補間の生成</h3>
<p>ここでは，矛盾した論理式 <script type="math/tex">A</script> および  <script type="math/tex">B</script> の組に対して補間を計算する手順について説明する．
なお，<script type="math/tex">A</script> および <script type="math/tex">B</script> が命題論理式の場合に焦点を当てる．
命題論理を対象とした DPLL ベースの SAT ソルバは CDCL (矛盾に基づく節学習) を実装しており，したがって，充足不能な式のための導出証明を生成できることを思い返してほしい．
導出証明を計算する方法の詳細は 9.5 節で述べられている．</p>
<p>DPLL ベースの SAT ソルバは，連言標準形 (CNF) で与えられた命題論理式に対して動作することを思い返してほしい．
<script type="math/tex">X</script> を命題変数の集合とする．
リテラルは変数 <script type="math/tex">x_i \in X</script> またはその否定 <script type="math/tex">\overline{x}_i</script> である．
節 <script type="math/tex">C</script> はリテラルの選言であり，リテラルの集合として表現する．
空の節 <script type="math/tex">\emptyset</script> はリテラルを含まない．
CNF の式は節の連言であり，節の集合として表現することもできる．</p>
<p>2 つの節 <script type="math/tex">A \vee x</script> および <script type="math/tex">B \vee \overline{x}</script> 間の<strong>導出</strong> (resolution) の原則を思い返してほしい．
<script type="math/tex">A \vee x</script> と <script type="math/tex">B \vee \overline{x}</script> をいずれも満たす割当は，同様に <script type="math/tex">A \vee B</script> も満たす．
すなわち，
<script type="math/tex; mode=display">
\frac{A \vee x \qquad B \vee \overline{x}}{A \vee B}
</script>
となる．
この変数 <script type="math/tex">x</script> をピボット変数という．
節 <script type="math/tex">A \vee x</script> および <script type="math/tex">B \vee \overline{x}</script> のピボット変数 <script type="math/tex">x</script> による導出節を <script type="math/tex">Res(A, B, x)</script> と書く．</p>
<p>ここで，第9章 (定義 9.6) の導出証明の定義を思い返そう．
導出証明<script type="math/tex">\mathcal{R}</script> は DAG <script type="math/tex">(V_{\mathcal{R}}, E_{\mathcal{R}}, piv_{\mathcal{R}}, l_{\mathcal{R}}) </script> であり，<script type="math/tex">V_{\mathcal{R}}</script> は頂点の集合，<script type="math/tex">E_{\mathcal{R}}</script> は辺の集合，<script type="math/tex">piv_{\mathcal{R}}</script> は頂点へのピボット変数によるラベル付け，<script type="math/tex">l_{\mathcal{R}}</script> は頂点への節のラベル付けである．
初期ノードは入次数 <script type="math/tex">0</script> をもち，式の一部である節に対応する．
他のすべての頂点は内部ノードであり，入次数 <script type="math/tex">2</script> をもつ．
これらは，他の節から導出によって得られた節に対応する．
内部頂点 <script type="math/tex">v</script> と辺 <script type="math/tex">(v_1,v), (v_2,v) \in E_{\mathcal{R}}</script> に対して，<script type="math/tex">v</script> 導出節によってラベル付けされる必要がある．
すなわち，以下の関係が成り立つ．
<script type="math/tex; mode=display">
l_{\mathcal{R}}(v) = Res(l_{\mathcal{R}}(v_1), l_{\mathcal{R}}(v_2), piv_{\mathcal{R}}(v))
</script>
この場合，頂点 <script type="math/tex">v_1</script> および <script type="math/tex">v_2</script> が <script type="math/tex">v</script> の親であると言う．
底頂点は出次数 <script type="math/tex">0</script> であり，空の節でラベル付けされる．
<script type="math/tex">piv_{\mathcal{R}}(v)</script> が <script type="math/tex">l_{\mathcal{R}}(v^+)</script> となるような <script type="math/tex">v</script> の親を <script type="math/tex">v^+</script> と書き，
<script type="math/tex">\neg piv_{\mathcal{R}}(v)</script> が <script type="math/tex">l_{\mathcal{R}}(v^-)</script> となるような <script type="math/tex">v</script> の親を <script type="math/tex">v^-</script> と書く．</p>
<h4 id="107">例 10.7</h4>
<div class="admonition example">
<p class="admonition-title">例 10.7</p>
<p>以下の論理式を考える．
<script type="math/tex; mode=display">\begin{align}
(a_1 \vee \overline{a}_2) \wedge (\overline{a}_1 \vee \overline{a}_3) \wedge a_2 \wedge (\overline{a}_2 \vee a_3) \wedge (a_2 \vee a_4) \wedge \overline{a}_4 \tag{10.10}
\end{align}</script>
この論理式は充足不能である．
導出証明は図 10.4 に示す通りである．</p>
<p><center>
<img src="../img/lec12-fig_10_4.pdf" width="350">
<br>
図 10.4: 式 10.10 に対する導出証明
</center></p>
</div>
<p>ここで，節の集合を集合 <script type="math/tex">A</script> と <script type="math/tex">B</script> に分割することを考える．
充足不能な CNF の組 <script type="math/tex">(A, B)</script> の <script type="math/tex">(A, B)</script>-反駁 <script type="math/tex">\mathcal{R}</script> とは，各初期頂点 <script type="math/tex">v \in V_{\mathcal{R}}</script> に対して <script type="math/tex">l_{\mathcal{R}}(v)</script> が <script type="math/tex">A</script> または <script type="math/tex">B</script> のいずれかの要素であるものである．
<strong>補間系</strong> (interpolation system) とは，<script type="math/tex">(A, B)</script>-反駁を入力とし，その反駁から補間を構築する手続きである．</p>
<h4 id="108-mcmillan">定義 10.8 (McMillan の補間系)</h4>
<div class="admonition abstract">
<p class="admonition-title">定義 10.8 (McMillan の補間系)</p>
<p>McMillan の補間系 <script type="math/tex">Itp</script> は <script type="math/tex">(A, B)</script>-反駁 <script type="math/tex">\mathcal{R}</script> における頂点を，以下のように論理式へと対応づける．</p>
<ol>
<li>
<script type="math/tex">l_{\mathcal{R}}(v) = C</script> かつ <script type="math/tex">C \in A</script> である初期頂点 <script type="math/tex">v</script> は <script type="math/tex">C|_{B}</script> へと対応づけられる．すなわち，<script type="math/tex">B</script> に現れるリテラルのみが保持される．</li>
<li>
<script type="math/tex">l_{\mathcal{R}}(v) = C</script> かつ <script type="math/tex">C \in B</script> である初期頂点 <script type="math/tex">v</script> は <script type="math/tex">true</script> へと対応づけられる．</li>
<li>
<script type="math/tex">x</script> を ピボット変数とする内部頂点 <script type="math/tex">v</script> を考える．
    もし <script type="math/tex">x</script> が <script type="math/tex">B</script> に現れていれば，
    <script type="math/tex; mode=display">
    Itp(v) = Itp(v^+) \wedge Itp(v^-)
    </script>
    とする．
    もし <script type="math/tex">x</script> が <script type="math/tex">B</script> に現れていなければ，
    <script type="math/tex; mode=display">
    Itp(v) = Itp(v^+) \vee Itp(v^-)
    </script>
    とする．</li>
</ol>
</div>
<p>論理式 <script type="math/tex">Itp(v)</script> は，<script type="math/tex">v</script> に対する<strong>部分補間</strong> (partial interpolant) と呼ばれる．
補間系によって生成される補間は，底頂点に対する部分補間である．</p>
<h4 id="109">例 10.9</h4>
<div class="admonition example">
<p class="admonition-title">例 10.9</p>
<p>式 10.10 を以下のように分割する．
<script type="math/tex">A</script> を式 <script type="math/tex">(a_1 \vee \overline{a}_2) \wedge (\overline{a}_1 \vee \overline{a}_3) \wedge a_2</script> とし，<script type="math/tex">B</script> を式 <script type="math/tex">(\overline{a}_2 \vee a_3) \wedge (a_2 \vee a_4) \wedge \overline{a}_4</script> とする．
McMillan の補間系で生成された部分補間を図 10.5 に示す．
最終的な補間は <script type="math/tex">\overline{a}_3 \wedge a_2</script> となる．</p>
<p><center>
<img src="../img/lec12-fig_10_5.pdf" width="350">
<br>
図10.5: McMillan の補間系の適用例
</center></p>
</div>
<p>その他の補間系については，この章の参考文献に記載されている．
他の一階論理の部分論理に対する補間手続きについても，参考文献の中で触れている．</p>
<h3 id="1043-craig">10.4.3 Craig 補間を用いた到達可能性検査</h3>
<p>Craig 補間を用いたモデル検査では，有界モデル検査 (BMC) 形式の展開を出発点としている．
<script type="math/tex">\mathbf{AG}p</script> という形の特性について，与えられた境界 <script type="math/tex">k</script> に対して BMC が行う変換 (式 10.2) を思い返してほしい．
<script type="math/tex; mode=display">\begin{align}
S_0(s_0) \wedge \bigwedge_{i=0}^{k-1}R(s_i, s_{i+1}) \wedge \bigvee_{i=0}^{k} \neg p(s_i) \tag{10.11}
\end{align}</script>
ここで，上の式に対する 3 つの変更点を考えてみる．
まず，初期状態の集合 <script type="math/tex">S_0</script> に含まれるすべての状態が <script type="math/tex">p</script> でラベル付けされていることが確認済みだと仮定する．
したがって，選言肢 <script type="math/tex">p(s_0)</script> は冗長であるため，式から省略することができる．
さらに，任意の集合 <script type="math/tex">\mathcal{Q}</script> を初期状態の集合として考える．
最後に，式 10.11 の論理積を 2 つに分割し，それぞれ <script type="math/tex">A</script> および <script type="math/tex">B</script> と呼ぶことにする．
すると，以下が得られる．
<script type="math/tex; mode=display">\begin{align}
\underbrace{\mathcal{Q}(s_0) \wedge R(s_0, s_1)}_{A} \quad \text{ and }\quad \underbrace{\bigwedge_{i=1}^{k-1}R(s_i, s_{i+1}) \wedge \bigvee_{i=1}^{k} \neg p(s_i)}_{B} \tag{10.12}
\end{align}</script>
ここで <script type="math/tex">A \wedge B</script> が充足不能だと仮定する．
このとき，<script type="math/tex">A</script> と <script type="math/tex">B</script> は矛盾しており，Craig の定理により補間 <script type="math/tex">I</script> の存在が導かれる．
<script type="math/tex">A</script> と <script type="math/tex">B</script> に共通な変数はベクトル <script type="math/tex">s_1</script> のみであり，したがって <script type="math/tex">I</script> は <script type="math/tex">s_1</script> のみに関する述語となることを見てほしい．
次の補題を記しておく．</p>
<h4 id="1010">補題 10.10</h4>
<div class="admonition abstract">
<p class="admonition-title">補題 10.10</p>
<p>先ほど定義した <script type="math/tex">A</script> および <script type="math/tex">B</script> が矛盾しており，<script type="math/tex">A</script> および <script type="math/tex">B</script> の補間 <script type="math/tex">I</script> が与えられたとき，以下が満たされる．</p>
<ol>
<li>
<script type="math/tex">I</script> は，<script type="math/tex">\neg p</script> でラベルづけされた状態を含まない．</li>
<li>
<script type="math/tex">I</script> は <script type="math/tex">\mathcal{Q}</script> の像の上方近似となる．すなわち，<script type="math/tex">post\text{-}image(\mathcal{Q}) \subseteq I</script> となる．</li>
</ol>
</div>
<div class="admonition note">
<p class="admonition-title">証明</p>
<p>最初の主張について，Craig の定理が <script type="math/tex">I</script> は <script type="math/tex">B</script> と矛盾すると述べていることを思い出そう．
矛盾を導くため，<script type="math/tex">\neg p(s_1)</script> かつ <script type="math/tex">I(s_1)</script> となる状態 <script type="math/tex">s_1</script> の存在を仮定する．
このとき，<script type="math/tex">B</script> の右側の連言肢は満たされる．
<script type="math/tex">R</script> が左全関係であることから，左側の連言肢は満たすことができる．</p>
<p>2 つ目の主張について，<script type="math/tex">post\text{-}image(\mathcal{Q})</script> に含まれているが，<script type="math/tex">I</script> を満たさない状態 <script type="math/tex">s_1</script> が存在すると仮定して，矛盾を導く．
<script type="math/tex">A</script> は <script type="math/tex">I</script> を含意するので，状態 <script type="math/tex">s_1</script> を含んでいる <script type="math/tex">A</script> を満たすような割当を得ることはできない．
したがって，<script type="math/tex">\mathcal{Q}</script> 内のどの状態からも <script type="math/tex">s_1</script> への遷移はあってはならず，これは <script type="math/tex">s_1 \in post\text{-}image(\mathcal{Q})</script> と矛盾する．
(証明終)</p>
</div>
<p>ここで，集合 <script type="math/tex">I</script> は必ずしも <script type="math/tex">post\text{-}image(\mathcal{Q})</script> と<strong>等しい</strong> (equal) とは限らないことを注記しておく．
<script type="math/tex">I</script> はさらなる状態を含むかもしれず，そのため像の計算は上方近似となる．</p>
<p>手続き <script type="math/tex">CraigReachability</script> (図10.6) は，Craig 補間を到達可能性検査に応用したものである．
まず，<script type="math/tex">\neg p</script> がラベル付けされた初期状態があるかについて検証しなければならないことを思い出してほしい．
仮にそうであれば，この特性が偽であることがわかり，手続きは終了する．</p>
<div class="admonition note">
<p class="admonition-title">図 10.6: Craig 補間による像の上方近似計算を用いた到達性検査の手続き</p>
<p><center>
<img src="../img/lec12-fig10_6.pdf" width="800">
</center></p>
</div>
<p>そうでなければ，この手続きは小さな <script type="math/tex">k</script> の値から開始される．
状態集合 <script type="math/tex">\mathcal{Q}</script> は，初期状態の集合として初期化される．
そして，集合 <script type="math/tex">\mathcal{Q}</script> を始点として，境界 <script type="math/tex">k</script> について式 10.12 を構築する．
このインスタンスが充足不能である場合, Craig 補間 <script type="math/tex">I</script> が計算され, これは補題 10.10 から <script type="math/tex">\mathcal{Q}</script> の像の上方近似となる． 
もし，この補間が <script type="math/tex">\mathcal{Q}</script> に含まれるならば，<script type="math/tex">\mathcal{Q}</script> はその像の下で閉じており，したがって帰納不変式となる．
<script type="math/tex">\mathcal{Q}</script> は <script type="math/tex">\neg p</script> の状態を含まないので，この性質が成り立つことが結論付けられる．
そうでなければ，手続き <script type="math/tex">CraigReachability</script> は次の繰り返しに移り，<script type="math/tex">\mathcal{Q} \cup I</script> の像が計算される．</p>
<p>ここで，式 10.12 が充足可能であった場合について説明する．
このとき，以下の 2 つの場合のいずれかとなる．</p>
<ul>
<li>
<script type="math/tex">\mathcal{Q} = S_0</script> であった場合，このアルゴリズムは <script type="math/tex">k</script> の値を新たに設定した後，最初の繰り返しを実行する．
したがって，<script type="math/tex">\mathcal{Q}</script> はまだ上方近似されていないおらず，検査した式は BMC のインスタンスとなる．
そのため，<script type="math/tex">A \wedge B</script> への充足割当は <script type="math/tex">\mathbf{AG}p</script> に対する本当の反例である．
この手続きはこれを報告した後，終了する．</li>
<li>そうでない場合，<script type="math/tex">\mathcal{Q}</script> が到達不可能な状態を含んでいる可能性があることから，この性質については何も結論づけることができない．
この手続きは，<script type="math/tex">\mathcal{Q}</script> を初期状態の集合へとリセットし，<script type="math/tex">k</script> を増加させる．</li>
</ul>
<h3 id="1044">10.4.4 完全性についての議論</h3>
<p>この手続きは<strong>健全</strong> (sound) である．
つまり，<script type="math/tex">\mathcal{Q} \subseteq I</script> が検出されたとき，<script type="math/tex">\mathbf{AG}p</script> に対する帰納不変式が実際に得られる．
これは反復回数に対する帰納法と補題 10.10 によって示される．
この手続きが返す反例が実際に本物かという議論は，BMC が本物の反例を返すことを主張するために用いたものと同じである．</p>
<p>あとは，この手続きが<strong>完全</strong> (complete) であること，つまり，いつか終了することを示すだけである．
矛盾を導くため，この手続きが終了しないと仮定する．
まず，<script type="math/tex">k</script> がいつか必ず増加することを示す．
この目的のために，仮にそうでなければ集合 <script type="math/tex">\mathcal{Q}</script> の列は単調増加し，各反復により少なくとも 1 つの状態が <script type="math/tex">\mathcal{Q}</script> に追加されることを見てほしい．
<script type="math/tex">\mathcal{Q}</script> は有限の集合から選ばれるため，これを無限に繰り返すことはできない．</p>
<p>したがって，<script type="math/tex">k</script> は増加する．
定理 10.6 により補間 <script type="math/tex">I</script> がもつ性質を思い返してほしい．
この定理は <script type="math/tex">I</script> が <script type="math/tex">B</script> と矛盾することを述べている．
結果として，<script type="math/tex">I</script> は <script type="math/tex">\neg p</script> でラベル付けされた状態を含まず，さらに <script type="math/tex">I</script> のどの状態も <script type="math/tex">k - 1</script> 回以下の遷移で <script type="math/tex">\neg p</script> の状態に到達することはできない．</p>
<p>まず，<script type="math/tex">M \nvDash \mathbf{AG}p</script> であった場合について考える．
<script type="math/tex">k</script> の値は最終的にその特性に対する最短の反例の長さまで増加する．
その際の SAT インスタンスは充足可能であり，この手続きは終了する．</p>
<p>
<script type="math/tex">M \vDash \mathbf{AG}p</script> の場合について，まず <script type="math/tex">M</script> の直径の定義を思い出そう．
直径とは，Kripke 構造における任意の 2 状態間での最短経路の中で，最も長いものをいう．
いつか <script type="math/tex">k</script> は <script type="math/tex">M</script> の直径に到達する．
このとき，補間はまさに <script type="math/tex">\neg p</script> の状態に到達しないような到達可能状態の集合となる．
この集合は像の中で閉じており，この手続きは終了する．</p>
<h2 id="105-pdr">10.5 特性指向到達可能性検査 (PDR)</h2>
<h3 id="1051">10.5.1 概要</h3>
<p>この章でこれまで述べてきたアプローチは，遷移関係の展開に依存したものであった．
つまり，ソルバへと渡される式は論理関係の複数のコピーから構成されている．
その結果，メモリ消費量が膨大になりうる．
ここでは，遷移関係のコピーを作成することなく SAT に基づく到達可能性検査を行う技術である<strong>特性指向到達可能性検査</strong> (property-directed reachability, PDR) について示す．
したがって，通常，PDR はよりメモリ効率がよい．
Bradley の論文 <sup id="fnref:78"><a class="footnote-ref" href="#fn:78">29</a></sup> では PDR は IC3 と呼ばれている．</p>
<p>Craig 補間による到達可能性検査と同様に，PDR は初期状態集合の像の上方近似を計算する．
したがって，これは上方近似到達可能性検査のインスタンスであり，定義 10.5 の条件を満たす帰納不変式 <script type="math/tex">I</script> を計算することを目的としている．</p>
<p>Craig 補間による到達可能性検査では，このような候補不変式がただ一つのみ用いられる．
Craig 補間による到達可能性検査と PDR の重要な違いは，PDR が<strong>複数の</strong>候補不変式を用いることである．
候補不変式は<strong>フレーム</strong> (frame) と呼ばれ，<script type="math/tex">F_0, \ldots, F_k</script> と表記される．
各 <script type="math/tex">F_i</script> は <script type="math/tex">S</script> の部分集合である．
このアルゴリズムは以下の４つの不変性質を維持する．</p>
<ul>
<li><strong>(Inv1)</strong> フレーム <script type="math/tex">F_0</script> は初期状態の集合を含む．つまり，<script type="math/tex">S_0 \subseteq F_0</script> が成り立つ．</li>
<li><strong>(Inv2)</strong> <script type="math/tex">F_i</script> の列は単調である．つまり，<script type="math/tex">F_i \subseteq F_{i+1}</script> が成り立つ．</li>
<li><strong>(Inv3)</strong> どのフレームも <script type="math/tex">\neg p</script> の状態を含まない．</li>
<li><strong>(Inv4)</strong> フレーム <script type="math/tex">F_{i+1}</script> はフレーム <script type="math/tex">F_i</script> の像の上方近似となる．つまり，
<script type="math/tex; mode=display">
post\text{-}image(F_i) \subseteq F_{i+1}
</script>
が成り立つ．</li>
</ul>
<p>フレーム <script type="math/tex">F_0, \ldots, F_k</script> によって与えられる <script type="math/tex">S</script> の分割を，図 10.7 に示す．</p>
<p><center>
<img src="../img/lec12-fig_10_7.pdf" width="400">
<br>
図10.7: <script type="math/tex">S</script> の部分集合 <script type="math/tex">F_0, \ldots, F_k</script> の例 (<script type="math/tex">k=2</script>)
</center></p>
<p>ここで，ある状態集合が帰納不変式であるために満たすべき条件 (定義10.5) を思い返してみよう．
PDR の不変性質 (Inv1) および (Inv2) から，すべての <script type="math/tex">F_i</script> は初期状態の集合を含むことがわかる．
また，<script type="math/tex">\neg p</script> の状態は含まない (Inv3)．
ここで，一度 <script type="math/tex">F_i = F_{i+1}</script> となる <script type="math/tex">F_i</script> が得られたら，<script type="math/tex">post\text{-}image(F_i) \subseteq F_i</script> となる (Inv4) ことを見てほしい．
したがって，<script type="math/tex">F_i = F_{i+1}</script> のとき，<script type="math/tex">F_i</script> は <script type="math/tex">\mathbf{AG}p</script> の帰納不変式となる．</p>
<p>新しいフレームは，<script type="math/tex">p</script> でラベル付けされたすべての状態からなる集合を含むよう初期化される．
これは，<script type="math/tex">\mathbf{AG}p</script> を証明しうる最大の候補不変式である．
PDR の重要な操作は，<script type="math/tex">F_i = F_{i+1}</script> の反例となる状態をフレームから取り除くことである．
常に <script type="math/tex">F_i \subseteq F_{i+1}</script> であるため，これらは <script type="math/tex">F_{i+1}</script> に含まれるが <script type="math/tex">F_i</script> には含まれないような状態でなければならない．
PDR は，初期状態から <script type="math/tex">\neg p</script> の状態への反例パスを見つけるか，あるいは <script type="math/tex">F_i = F_{i+1}</script> を満たすフレームを得るまでこれを行う．</p>
<h3 id="1052">10.5.2 主な手続き</h3>
<p>アルゴリズムの主なループは図 10.8 に擬似コードとして示されている．
最初のステップとして，<script type="math/tex">\neg p</script> でラベル付けされた初期状態があるかどうかをチェックし，その場合，<script type="math/tex">\mathbf{AG}p</script> は反駁され，手続きは終了する．
そうでなければ，アルゴリズムは先へと進み，初期状態がすべて <script type="math/tex">p</script> でラベル付けされていると仮定できる．</p>
<div class="admonition note">
<p class="admonition-title">図10.8: PDR のメインループ</p>
<p><center>
<img src="../img/lec12-fig10_8.pdf" width="800">
</center></p>
</div>
<p>次に，<script type="math/tex">k</script> を <script type="math/tex">0</script> に設定し，フレーム <script type="math/tex">F_0</script> を構築する．
<script type="math/tex">I</script> は初期状態の集合として初期化される．
この準備段階の後，(Inv1)-(Inv4) が成立することは自明である．
主なループは 4 つのアクションを実行する：</p>
<ul>
<li>
<script type="math/tex">extendFrontier</script> (図10.9) を呼び出して，新しいフレーム <script type="math/tex">F_{k+1}</script> を設定する．</li>
<li>
<script type="math/tex">propagateClauses</script> (図10.11) を呼び出して，節を前方伝搬させる．</li>
<li>
<script type="math/tex">\mathbf{AG}p</script> を証明する帰納不変式が得られたかどうかを確認し，その場合は終了する．</li>
<li>そうでなければ，<script type="math/tex">k</script> を 1 つ増やして最初のステップに進む．</li>
</ul>
<div class="admonition note">
<p class="admonition-title">図10.9: PDR において新たなフレームを追加する手続き</p>
<p><center>
<img src="../img/lec12-fig10_9.pdf" width="800">
</center></p>
</div>
<div class="admonition note">
<p class="admonition-title">図10.10: PDR において帰納法に対する反例を削除する手続き</p>
<p><center>
<img src="../img/lec12-fig10_10.pdf" width="800">
</center></p>
</div>
<div class="admonition note">
<p class="admonition-title">図10.11: 他のフレームへ節を伝播する手続き</p>
<p><center>
<img src="../img/lec12-fig10_11.pdf" width="800">
</center></p>
</div>
<p>以下，それぞれのサブ手続きについて順番に説明する．</p>
<h3 id="1053">10.5.3 フロンティアの拡張</h3>
<p>手続き <script type="math/tex">extendFrontier</script> は新しいフレーム <script type="math/tex">F_{k+1}</script> を追加する．
フレームは，<script type="math/tex">p</script> でラベル付けされた状態集合で初期化される．これは，<script type="math/tex">\mathbf{AG}p</script> を証明するために使用できる帰納不変式の中で最大のものである．
新しいフレームは (Inv1)-(Inv3) を満たすことが見て取れる．
しかし，(Inv4) には違反する可能性がある．
つまり，ある状態 <script type="math/tex">s \in F_k</script> が存在し，<script type="math/tex">s</script> から <script type="math/tex">F_{k+1}</script> に含まれない <script type="math/tex">s'</script> への遷移が存在するかもしれない．
手続き <script type="math/tex">extendFrontier</script> のループは，充足可能性判定を用いてこれらの遷移を特定し，<script type="math/tex">removeCTI</script> を呼び出してそのような遷移の元となる状態 <script type="math/tex">s</script> を <script type="math/tex">F_k</script>から削除する．
それらが削除された後，すべての不変式は再構成される．</p>
<p>図 10.12 を用いて，手続き <script type="math/tex">removeCTI</script> が取る手順を説明する．
この手続きには，状態 <script type="math/tex">s</script> とその状態が見つかったフレーム <script type="math/tex">F_i</script> のインデックスがパラメータとして与えられる．
さらに，この手続きには <script type="math/tex">\neg p</script> の状態に到達可能な状態のみ渡すことを保証する．
手続き <script type="math/tex">removeCTI</script> は，初期状態から <script type="math/tex">i</script> 回以下のステップで状態 <script type="math/tex">s</script> に到達できるかどうかを判定することを目的としている．</p>
<p><center>
<img src="../img/lec12-fig_10_12.pdf" width="400">
<br>
図10.12: 帰納法に対する反例の削除の例
</center></p>
<p>手続き <script type="math/tex">removeCTI</script> は以下の 3 つの場合を区別する：</p>
<ul>
<li>まず，<script type="math/tex">s</script> が初期状態であるかどうかをチェックする．
この場合，初期状態から <script type="math/tex">\neg p</script> の状態へのパスが存在することになり，<script type="math/tex">\mathbf{AG}p</script> が反駁されたことになる．
そして，この手続きは停止する．</li>
<li>そうでなければ，この手続きは，充足可能性ソルバを用いて <script type="math/tex">F_i</script> から <script type="math/tex">s</script> への遷移が存在するかどうかをチェックする．
存在しなければ，初期状態から <script type="math/tex">i</script> 回以下のステップで状態 <script type="math/tex">s</script> に到達できないことを示したこととなる．
そして，この手続きから戻る．</li>
<li>
<script type="math/tex">F_i</script> 内の <script type="math/tex">t</script> から <script type="math/tex">s</script> への遷移が存在する場合，状態集合 <script type="math/tex">F_i</script> は <script type="math/tex">i</script> 回のステップで到達可能な状態の上方近似であるため，何も結論づけることはできない．
したがって，状態 <script type="math/tex">t</script> 自体は <script type="math/tex">i</script> 回のステップで到達できないかもしれない．
どちらの場合か決定するため，この手続きは，状態 <script type="math/tex">t</script> を引数，<script type="math/tex">i - 1</script> をフレームとして再帰的に自分自身を呼び出すことで，<script type="math/tex">t</script> が <script type="math/tex">F_{i-1}</script> から到達可能であるか判定する．
その前に，フレーム <script type="math/tex">F_0 \sim F_i</script> から状態 <script type="math/tex">s</script> を削除しておく．</li>
</ul>
<h3 id="1054">10.5.4 完全性についての議論</h3>
<p>まず，<strong>健全性</strong> (soundness) を示し，次に<strong>停止性</strong> (termination) を示す．</p>
<h4 id="_1">健全性</h4>
<p>
<script type="math/tex">\mathit{PDR}</script> が "<script type="math/tex">M \vDash \mathbf{AG}p</script>" を返す場合の正しさについては 10.5.1 節で既に述べた通りである．
<script type="math/tex">\mathit{PDR}</script> が <script type="math/tex">removeCTI</script> において "<script type="math/tex">M \nvDash \mathbf{AG}p</script>" を返した場合を考える．
<script type="math/tex">removeCTI</script> のパラメータ <script type="math/tex">s</script> が <script type="math/tex">\neg p</script> でラベル付けされた状態に到達可能な状態であることは容易にわかる．
したがって，<script type="math/tex">\neg p</script> とラベル付けされた状態に到達できる初期状態が存在するため <script type="math/tex">M</script> は <script type="math/tex">\mathbf{AG}p</script> を満たさない．</p>
<h4 id="_2">停止性</h4>
<p>まず，<script type="math/tex">removeCTI</script> の停止性について述べる．
状態 <script type="math/tex">s</script> は有限個の前状態をもち，各反復はソルバが見つけた前状態を削除するため，この <script type="math/tex">\mathbf{while}</script> ループは最終的に停止する．
また，再帰呼び出しのたびに <script type="math/tex">i</script> は減少するため，再帰はいつか停止する．
<script type="math/tex">\neg p</script> となる後状態をもつ状態は有限であり，<script type="math/tex">removeCTI</script> は <script type="math/tex">F_k</script> から <script type="math/tex">s</script> を削除するため，<script type="math/tex">extendFrontier</script> のループはいつか終了する．</p>
<p>
<script type="math/tex">\mathit{PDR}</script> の停止性に関する重要な論点は，<script type="math/tex">\mathit{PDR}</script> のループの反復ごとに <script type="math/tex">k</script> が増加することである．
<script type="math/tex">F_i</script> は有限集合から得られた列であり，厳密に増加することを思い出してほしい．
したがって，<script type="math/tex">k</script> が十分大きければ，ある <script type="math/tex">i</script> について <script type="math/tex">F_i = F_{i+1}</script> となり，手続きは停止する．</p>
<h2 id="_3">書誌情報</h2>
<p>命題論理 SAT を用いた有界モデル検査技術は，1999 年に Biere ら <sup id="fnref:59"><a class="footnote-ref" href="#fn:59">2</a></sup><sup id="fnref:58"><a class="footnote-ref" href="#fn:58">3</a></sup> によって導入された．
時相論理式の有界符号化については，かなりの数の研究が行われてきた．
境界 <script type="math/tex">k</script> は，反例における状態の数として解釈されることもあれば，時として (この章でそうしたように) 遷移の数としても解釈されうることに注意が必要である．
文献 <sup id="fnref2:59"><a class="footnote-ref" href="#fn:59">2</a></sup> には，任意の LTL 特性を展開するための文法的な方法が含まれているが，結果として得られる式の大きさは少なくとも 2 次関数となる <sup id="fnref:347"><a class="footnote-ref" href="#fn:347">4</a></sup>．
ACTL* の符号化は <sup id="fnref:412"><a class="footnote-ref" href="#fn:412">5</a></sup> で，CTL* の符号化は <sup id="fnref:465"><a class="footnote-ref" href="#fn:465">6</a></sup> で与えられている．</p>
<p>完全性閾値という用語は文献 <sup id="fnref:318"><a class="footnote-ref" href="#fn:318">7</a></sup> で導入された．
文献 <sup id="fnref3:59"><a class="footnote-ref" href="#fn:59">2</a></sup> では，<script type="math/tex">M</script> の再帰直径が <script type="math/tex">\mathbf{EF}p</script> 反例の完全性閾値であるという定理が述べられている．
LTL モデル検査は，特性の大きさに対して PSPACE 完全であること <sup id="fnref:454"><a class="footnote-ref" href="#fn:454">8</a></sup> が知られているため，この論文では，モデルの大きさに対して多項式である LTL 特性の完全性閾値は存在しないことも推測されている．
この推測は，文献 <sup id="fnref:317"><a class="footnote-ref" href="#fn:317">9</a></sup> において，指数関数的な境界を必要とする LTL 特性の単純な例を用いて示されている．</p>
<p>BMCは当初，デジタル回路のモデルに適用された．
Verilog HDL で与えられた回路のための BMC の実装が，EBMC <sup id="fnref:395"><a class="footnote-ref" href="#fn:395">10</a></sup> ツールである．
ソフトウェアプログラムを対象とした BMC の類型が <sup id="fnref:165"><a class="footnote-ref" href="#fn:165">11</a></sup><sup id="fnref:140"><a class="footnote-ref" href="#fn:140">12</a></sup> で発表されており，それについては第 14 章で議論されている．</p>
<p>SAT ソルバを用いた <script type="math/tex">k</script>-帰納法は，Sheeran ら <sup id="fnref:445"><a class="footnote-ref" href="#fn:445">13</a></sup> や，Bjesse と Claessen <sup id="fnref:65"><a class="footnote-ref" href="#fn:65">14</a></sup> によって独自に提案された．
帰納の深さを削減するための特性強化 <sup id="fnref:81"><a class="footnote-ref" href="#fn:81">15</a></sup>，インクリメンタル SAT 解法による性能向上 <sup id="fnref:195"><a class="footnote-ref" href="#fn:195">16</a></sup>，時相論理特性の検証 <sup id="fnref:31"><a class="footnote-ref" href="#fn:31">17</a></sup> など，いくつかの最適化ならびに手法の拡張が提案されてきた．
<script type="math/tex">k</script>-帰納法の初期の応用は，ハードウェア設計に焦点を当てていた <sup id="fnref2:65"><a class="footnote-ref" href="#fn:65">14</a></sup><sup id="fnref:356"><a class="footnote-ref" href="#fn:356">18</a></sup><sup id="fnref2:445"><a class="footnote-ref" href="#fn:445">13</a></sup>．
その後，ソフトウェアプログラムへの応用が始まった <sup id="fnref:191"><a class="footnote-ref" href="#fn:191">19</a></sup><sup id="fnref:189"><a class="footnote-ref" href="#fn:189">20</a></sup>．</p>
<p>2002 年に，McMillan によって all-SAT に基づくモデル検査技術が発表された <sup id="fnref:380"><a class="footnote-ref" href="#fn:380">21</a></sup>．
2003 年には，McMillan は命題論理 SAT と Craig 補間を用いた非有界の到達可能性検査を導入した <sup id="fnref:381"><a class="footnote-ref" href="#fn:381">22</a></sup>．
導出証明から Craig 補間を計算する方法は，この論文よりも前から存在していた．
最初のシステムは，Huang <sup id="fnref:284"><a class="footnote-ref" href="#fn:284">23</a></sup>，Krajicek <sup id="fnref:316"><a class="footnote-ref" href="#fn:316">24</a></sup>，Pudlak <sup id="fnref:424"><a class="footnote-ref" href="#fn:424">25</a></sup> によって提案された．
McMillan は，より強い補間を生成する別のシステムを提案している <sup id="fnref2:381"><a class="footnote-ref" href="#fn:381">22</a></sup>．
より強い補間はより正確な近似をもたらすが，収束が遅くなる可能性がある．
生成された補間の論理的強度に関する異なる補間システム間の関係については，文献 <sup id="fnref:192"><a class="footnote-ref" href="#fn:192">26</a></sup> で議論されている．
部分補間要素による注釈を用いて補間系を提示する形式は，McMillan によって導入された <sup id="fnref:382"><a class="footnote-ref" href="#fn:382">27</a></sup>．</p>
<p>PDR の前身は Bradley が 2007 年に FMCAD で発表した論文 <sup id="fnref:80"><a class="footnote-ref" href="#fn:80">28</a></sup> で与えられており，ここでは個々の帰納節が計算される．
そして 2011 年の VMCAI で，Bradley によって PDR が提案された <sup id="fnref2:78"><a class="footnote-ref" href="#fn:78">29</a></sup>．
2012 年の SAT <sup id="fnref:79"><a class="footnote-ref" href="#fn:79">30</a></sup> でアルゴリズムの改良と明確化が，2012 年の CAV <sup id="fnref:266"><a class="footnote-ref" href="#fn:266">31</a></sup> で CTL への拡張がそれぞれ発表された．
一般化手続きに対する改良は 2013 年の FMCAD で発表した論文 <sup id="fnref:267"><a class="footnote-ref" href="#fn:267">32</a></sup> で行われた．
PDR と <script type="math/tex">k</script>-帰納法の組み合わせは 2016 年の FMCAD <sup id="fnref:297"><a class="footnote-ref" href="#fn:297">33</a></sup> で発表され，PDR と補間の組み合わせは 2014 年の CAV <sup id="fnref:484"><a class="footnote-ref" href="#fn:484">34</a></sup> で発表された．</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:164">
<p>W. Craig. Linear reasoning:A new form of the Herbrand-Gentzen theorem. J. Symbolic Logic, 22(3):250–268, 1957.&#160;<a class="footnote-backref" href="#fnref:164" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:59">
<p>A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic model checking without BDDs. In R. Cleaveland, editor, Tools and Algorithms for Construction and Analysis of Systems, TACAS, volume 1579 of Lecture Notes in Computer Science, pages 193–207. Springer, 1999.&#160;<a class="footnote-backref" href="#fnref:59" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:59" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:59" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:58">
<p>A. Biere, A. Cimatti, E. M. Clarke, M. Fujita, and Y. Zhu. Symbolic model checking using SAT procedures instead of BDDs. In Design Automation Conference, DAC, pages 317–320. IEEE Computer Society, 1999.&#160;<a class="footnote-backref" href="#fnref:58" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:347">
<p>T. Latvala, A. Biere, K. Heljanko, and T. A. Junttila. Simple bounded LTL model checking. In A. J. Hu and A. K. Martin, editors, Formal Methods in Computer-Aided Design, FMCAD, volume 3312 of Lecture Notes in Computer Science, pages 186–200. Springer, 2004.&#160;<a class="footnote-backref" href="#fnref:347" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:412">
<p>W. Penczek, B. Wozna, and A. Zbrzezny. Bounded model checking for the universal fragment of CTL. Fundam. Inf., 51(1-2):135–156, 2002.&#160;<a class="footnote-backref" href="#fnref:412" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:465">
<p>Z.-H. Tao, C.-H. Zhou, Z. Chen, and L.-F. Wang. Bounded model checking of CTL *. J. Comput. Sci. Technol., 22(1):39–43, 2007.&#160;<a class="footnote-backref" href="#fnref:465" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:318">
<p>D. Kroening and O. Strichman. Efficient computation of recurrence diameters. In L. D. Zuck, P. C. Attie, A. Cortesi, and S. Mukhopadhyay, editors, Verification, Model Checking, and Abstract Interpretation, VMCAI, volume 2575 of Lecture Notes in Computer Science, pages 298–309. Springer, 2003.&#160;<a class="footnote-backref" href="#fnref:318" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:454">
<p>A. P. Sistla and E. M. Clarke. The complexity of propositional linear temporal logics. J. ACM, 32(3):733–749, 1985.&#160;<a class="footnote-backref" href="#fnref:454" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:317">
<p>D. Kroening, J. Ouaknine, O. Strichman, T. Wahl, and J. Worrell. Linear completeness thresholds for bounded model checking. In G. Gopalakrishnan and S. Qadeer, editors, Computer Aided Verification, CAV, volume 6806 of Lecture Notes in Computer Science, pages 557–572. Springer, 2011.&#160;<a class="footnote-backref" href="#fnref:317" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:395">
<p>R. Mukherjee, D. Kroening, and T. Melham. Hardware verification using software analyzers. In 2015 IEEE Computer Society Annual Symposium on VLSI, ISVLSI, pages 7–12. IEEE Computer Society, 2015.&#160;<a class="footnote-backref" href="#fnref:395" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:165">
<p>D. W. Currie, A. J. Hu, and S. P. Rajan. Automatic formal verification of DSP software. In Design Automation Conference, DAC, pages 130–135. ACM, 2000.&#160;<a class="footnote-backref" href="#fnref:165" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:140">
<p>E. M. Clarke, D. Kroening, and F. Lerda. A tool for checking ANSI-C programs. In K. Jensen and A. Podelski, editors, Tools and Algorithms for the Construction and Analysis of Systems, TACAS, volume 2988 of Lecture Notes in Computer Science, pages 168–176. Springer, 2004.&#160;<a class="footnote-backref" href="#fnref:140" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:445">
<p>M. Sheeran, S. Singh, and G. Stålmarck. Checking safety properties using induction and a SAT-solver. In W. A. J. Hunt and S. D. Johnson, editors, Formal Methods in Computer Aided Design, FMCAD, volume 1954 of Lecture Notes in Computer Science, pages 108–125. Springer, 2000.&#160;<a class="footnote-backref" href="#fnref:445" title="Jump back to footnote 13 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:445" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:65">
<p>P. Bjesse and K. Claessen. SAT-based verification without state space traversal. In W. A. J. Hunt and S. D. Johnson, editors, Formal Methods in Computer-Aided Design, FMCAD, volume 1954 of Lecture Notes in Computer Science, pages 372–389. Springer, 2000.&#160;<a class="footnote-backref" href="#fnref:65" title="Jump back to footnote 14 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:65" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:81">
<p>M. C. Browne and E. M. Clarke. SML:A high level language for the design and verification of finite state machines. In IFIP WG 10.2 Working Conference from HDL Descriptions to Guaranteed Correct Circuit Designs, pages 269–292. International Federation for Information Processing, 1987.&#160;<a class="footnote-backref" href="#fnref:81" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:195">
<p>N. Eén and N. Sörensson. Temporal induction by incremental SAT solving. Electr. Notes Theor. Comput. Sci., 89(4):543–560, 2003.&#160;<a class="footnote-backref" href="#fnref:195" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
<li id="fn:31">
<p>R. Armoni, L. Fix, R. Fraer, S. Huddleston, N. Piterman, and M. Y. Vardi. SAT-based induction for temporal safety properties. Electr. Notes Theor. Comput. Sci., 119(2):3–16, 2005.&#160;<a class="footnote-backref" href="#fnref:31" title="Jump back to footnote 17 in the text">&#8617;</a></p>
</li>
<li id="fn:356">
<p>C. J. Lillieroth and S. Singh. Formal verification of FPGA cores. Nord. J. Comput., 6(3):299–319, 1999.&#160;<a class="footnote-backref" href="#fnref:356" title="Jump back to footnote 18 in the text">&#8617;</a></p>
</li>
<li id="fn:191">
<p>A. F. Donaldson, D. Kroening, and P. Rümmer. Automatic analysis of scratch-pad memory code for heterogeneous multicore processors. In J. Esparza and R. Majumdar, editors, Tools and Algorithms for the Construction and Analysis of Systems, TACAS, volume 6015 of Lecture Notes in Computer Science, pages 280–295. Springer, 2010.&#160;<a class="footnote-backref" href="#fnref:191" title="Jump back to footnote 19 in the text">&#8617;</a></p>
</li>
<li id="fn:189">
<p>A. F. Donaldson, L. Haller, D. Kroening, and P. Rümmer. Software verification using k-induction. In E. Yahav, editor, Static Analysis, SAS, volume 6887 of Lecture Notes in Computer Science, pages 351–368. Springer, 2011.&#160;<a class="footnote-backref" href="#fnref:189" title="Jump back to footnote 20 in the text">&#8617;</a></p>
</li>
<li id="fn:380">
<p>K. L. McMillan. Applying SAT methods in unbounded symbolic model checking. In E. Brinksma and K. G. Larsen, editors, Computer Aided Verification, CAV, volume 2404 of Lecture Notes in Computer Science, pages 250–264. Springer, 2002.&#160;<a class="footnote-backref" href="#fnref:380" title="Jump back to footnote 21 in the text">&#8617;</a></p>
</li>
<li id="fn:381">
<p>K. L. McMillan. Interpolation and SAT-based model checking. In W. A. J. Hunt and F. Somenzi, editors, Computer Aided Verification, CAV, volume 2725 of Lecture Notes in Computer Science, pages 1–13. Springer, 2003.&#160;<a class="footnote-backref" href="#fnref:381" title="Jump back to footnote 22 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:381" title="Jump back to footnote 22 in the text">&#8617;</a></p>
</li>
<li id="fn:284">
<p>G. Huang. Constructing Craig interpolation formulas. In Computing and Combinatorics, COCOON, volume 959 of Lecture Notes in Computer Science, pages 181–190. Springer, 1995.&#160;<a class="footnote-backref" href="#fnref:284" title="Jump back to footnote 23 in the text">&#8617;</a></p>
</li>
<li id="fn:316">
<p>J. Krajíček. Interpolation theorems, lower bounds for proof systems, and independence results for bounded arithmetic. J. Symbolic Logic, 62(2):457–486, 1997.&#160;<a class="footnote-backref" href="#fnref:316" title="Jump back to footnote 24 in the text">&#8617;</a></p>
</li>
<li id="fn:424">
<p>P. Pudlák. Lower bounds for resolution and cutting plane proofs and monotone computations. J. Symbolic Logic, 62(3):981–998, 1997.&#160;<a class="footnote-backref" href="#fnref:424" title="Jump back to footnote 25 in the text">&#8617;</a></p>
</li>
<li id="fn:192">
<p>V. D’Silva, D. Kroening, M. Purandare, and G. Weissenbacher. Interpolant strength. In G. Barthe and M. V. Hermenegildo, editors, Verification, Model Checking, and Abstract Interpretation, VMCAI, volume 5944 of Lecture Notes in Computer Science, pages 129–145. Springer, 2010.&#160;<a class="footnote-backref" href="#fnref:192" title="Jump back to footnote 26 in the text">&#8617;</a></p>
</li>
<li id="fn:382">
<p>K. L. McMillan. An interpolating theorem prover. Theor. Comput. Sci., 345(1):101–121, 2005.&#160;<a class="footnote-backref" href="#fnref:382" title="Jump back to footnote 27 in the text">&#8617;</a></p>
</li>
<li id="fn:80">
<p>A. R. Bradley and Z. Manna. Checking safety by inductive generalization of counterexamples to induction. In Formal Methods in Computer-Aided Design, FMCAD, pages 173–180. IEEE Computer Society, 2007.&#160;<a class="footnote-backref" href="#fnref:80" title="Jump back to footnote 28 in the text">&#8617;</a></p>
</li>
<li id="fn:78">
<p>A. R. Bradley. SAT-based model checking without unrolling. In R. Jhala and D. A. Schmidt, editors, Verification, Model Checking, and Abstract Interpretation, VMCAI, volume 6538 of Lecture Notes in Computer Science, pages 70–87. Springer, 2011.&#160;<a class="footnote-backref" href="#fnref:78" title="Jump back to footnote 29 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:78" title="Jump back to footnote 29 in the text">&#8617;</a></p>
</li>
<li id="fn:79">
<p>A. R. Bradley. Understanding IC3. In A. Cimatti and R. Sebastiani, editors, Theory and Applications of Satisfiability Testing, SAT, volume 7317 of Lecture Notes in Computer Science, pages 1–14. Springer, 2012.&#160;<a class="footnote-backref" href="#fnref:79" title="Jump back to footnote 30 in the text">&#8617;</a></p>
</li>
<li id="fn:266">
<p>Z. Hassan, A. R. Bradley, and F. Somenzi. Incremental, inductive CTL model checking. In P. Madhusudan and S. A. Seshia, editors, Computer Aided Verification, CAV, volume 7358 of Lecture Notes in Computer Science, pages 532–547. Springer, 2012.&#160;<a class="footnote-backref" href="#fnref:266" title="Jump back to footnote 31 in the text">&#8617;</a></p>
</li>
<li id="fn:267">
<p>Z. Hassan, A. R. Bradley, and F. Somenzi. Better generalization in IC3. In Formal Methods in Computer-Aided Design, FMCAD, pages 157–164. IEEE, 2013.&#160;<a class="footnote-backref" href="#fnref:267" title="Jump back to footnote 32 in the text">&#8617;</a></p>
</li>
<li id="fn:297">
<p>D. Jovanovic and B. Dutertre. Property-directed k-induction. In Formal Methods in Computer-Aided Design, FMCAD, pages 85–92. IEEE, 2016.&#160;<a class="footnote-backref" href="#fnref:297" title="Jump back to footnote 33 in the text">&#8617;</a></p>
</li>
<li id="fn:484">
<p>Y. Vizel and A. Gurfinkel. Interpolating property directed reachability. In Computer Aided Verification, CAV, volume 8559 of Lecture Notes in Computer Science, pages 260–276. Springer, 2014.&#160;<a class="footnote-backref" href="#fnref:484" title="Jump back to footnote 34 in the text">&#8617;</a></p>
</li>
</ol>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.annotate"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.ad660dcc.min.js"></script>
      
        <script src="../js/extra.js"></script>
      
        <script src="../js/config.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_CHTML"></script>
      
    
  </body>
</html>