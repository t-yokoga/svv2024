
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../lec11/">
      
      
        <link rel="next" href="../lec13/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.2">
    
    
      
        <title>第12回 SATに基づくモデル検査 - システム検証論 (2023)</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/earlyaccess/notosansjp.css">
    
      <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans:600,800">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Murecho&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+1p&family=Noto+Sans+JP&display=swap">
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+New&display=swap">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#12-sat" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="システム検証論 (2023)" class="md-header__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            システム検証論 (2023)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              第12回 SATに基づくモデル検査
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="システム検証論 (2023)" class="md-nav__button md-logo" aria-label="システム検証論 (2023)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    システム検証論 (2023)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec01/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第1回 モデル検査とは
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec02/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第2回 クリプキ構造と一階の論理表現
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec03/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第3回 ハードウェア・ソフトウェアのモデル化
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec04/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第4回 時相論理 CTL*
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec05/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第5回 CTL* ベースのその他の時相論理
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec06/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第6回 CTL モデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec07/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第7回 不動点計算によるモデル検査アルゴリズム
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec08/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第8回 LTL と CTL* のモデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec09/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第9回 二分決定グラフ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec10/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第10回 記号モデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec11/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第11回 命題論理の充足可能性判定
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    第12回 SATに基づくモデル検査
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    第12回 SATに基づくモデル検査
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#101" class="md-nav__link">
    <span class="md-ellipsis">
      10.1 有界モデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1 有界モデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1011" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.1 有界モデル検査の概要
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1012-reachability-property" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.2 到達可能性 (Reachability Property)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1.2 到達可能性 (Reachability Property)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101_1" class="md-nav__link">
    <span class="md-ellipsis">
      定理 10.1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.2
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1013-eventually-property" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.3 活性 (Eventually Property)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1014-ltl" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.4 LTL に対する有界モデル検査
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1015-completeness-thresholds" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.5 完全性閾値 (Completeness Thresholds)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1.5 完全性閾値 (Completeness Thresholds)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#104" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.4
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#102-k-" class="md-nav__link">
    <span class="md-ellipsis">
      10.2 k-帰納法による到達可能性検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.2 k-帰納法による到達可能性検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1021-sat" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.1 SAT を用いた帰納法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1022-k-" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.2 k-帰納法への一般化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1023" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.3 完全性についての議論
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      演習問題
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec13/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第13回 非有界モデル検査
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec14/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第14回 抽象化による検査コストの削減
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lec15/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    第15回 反例主導型抽象詳細化 (CEGAR)
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#101" class="md-nav__link">
    <span class="md-ellipsis">
      10.1 有界モデル検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1 有界モデル検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1011" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.1 有界モデル検査の概要
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1012-reachability-property" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.2 到達可能性 (Reachability Property)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1.2 到達可能性 (Reachability Property)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#101_1" class="md-nav__link">
    <span class="md-ellipsis">
      定理 10.1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102" class="md-nav__link">
    <span class="md-ellipsis">
      例 10.2
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1013-eventually-property" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.3 活性 (Eventually Property)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1014-ltl" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.4 LTL に対する有界モデル検査
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1015-completeness-thresholds" class="md-nav__link">
    <span class="md-ellipsis">
      10.1.5 完全性閾値 (Completeness Thresholds)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.1.5 完全性閾値 (Completeness Thresholds)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#103" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#104" class="md-nav__link">
    <span class="md-ellipsis">
      補題 10.4
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#102-k-" class="md-nav__link">
    <span class="md-ellipsis">
      10.2 k-帰納法による到達可能性検査
    </span>
  </a>
  
    <nav class="md-nav" aria-label="10.2 k-帰納法による到達可能性検査">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1021-sat" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.1 SAT を用いた帰納法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1022-k-" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.2 k-帰納法への一般化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1023" class="md-nav__link">
    <span class="md-ellipsis">
      10.2.3 完全性についての議論
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      演習問題
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="12-sat">第12回 SAT に基づくモデル検査</h1>
<p>この回では，教科書の第10章 "SAT-based Model Checking" の前半 (10 〜 10.2) について説明します．</p>
<div class="admonition summary">
<p class="admonition-title">概要</p>
<ul>
<li>有界モデル検査の概略</li>
<li>有界モデル検査を用いた到達可能性，活性，LTL 式の検証</li>
<li>
<script type="math/tex">k</script>-帰納法による検証</li>
</ul>
</div>
<p>命題論理の充足可能性 (SAT) および背景理論付き SAT (SMT) の性能とスケーラビリティは飛躍的に向上している．
ここでは，こうした改良を利用したモデル検査の技術をいくつか説明する．
最初の技術は，<strong>有界モデル検査</strong> (bounded model checking, BMC) <sup id="fnref:59"><a class="footnote-ref" href="#fn:59">1</a></sup><sup id="fnref:58"><a class="footnote-ref" href="#fn:58">2</a></sup> と呼ばれる手法で，与えられた深さの限度 <script type="math/tex">k</script> に対する モデル <script type="math/tex">M</script> と特性 <script type="math/tex">\phi</script> の展開 (unwinding) に対応する式を生成するものである．
この式は，モデル <script type="math/tex">M</script> において <script type="math/tex">\phi</script> が長さ <script type="math/tex">k</script> の反例によって反証可能な場合，かつそのときのみ充足可能となる．
したがって BMC は，主に設計の誤りを特定するために用いられる．</p>
<p>2 つめの技術である <strong>k-帰納法</strong> (k-induction) <sup id="fnref:445"><a class="footnote-ref" href="#fn:445">3</a></sup> は，帰納法によって <script type="math/tex">\phi</script> が証明可能か否かを判定するために BMC を用いている．
<script type="math/tex">k</script>-帰納法が利用可能となるのはある特定の特性のみで，帰納的な特性を記述することは難しい．
3 つめと 4 つめの技術は，<strong>Craig 補間を用いたモデル検査</strong> (model checking with Craig interpolation) <sup id="fnref:381"><a class="footnote-ref" href="#fn:381">4</a></sup> と，<strong>特性指向到達可能性</strong> (property-directed reachability, PDR) <sup id="fnref:78"><a class="footnote-ref" href="#fn:78">5</a></sup> で，<script type="math/tex">\phi</script> を推論する新たな帰納不変式を計算することを目的としている．
これらの技術はすべて主要な証明器として命題論理 SAT ソルバを利用しており，したがって命題論理 SAT 解法のさまざまな改善の恩恵を受けることができる．</p>
<p>DPLL に基づく最新の命題論理 SAT ソルバの詳細は，第 9 章で説明されている．
この章では，第 9 章で 述べた 2 つの重要な概念，すなわち，充足割り当てと導出証明を思い起こす．
それ以外の場合，SAT または SMT ソルバは，ブラックボックスとして扱われる．</p>
<h2 id="101">10.1 有界モデル検査</h2>
<h3 id="1011">10.1.1 有界モデル検査の概要</h3>
<p>ここでは，第 4 章で述べた線形時間論理 (LTL) のクラスに属する性質に焦点を絞って説明する．
そこで論じられているように，LTL の式は <script type="math/tex">\textbf{A} \phi</script> の形をもち，ここで <script type="math/tex">\phi</script> は LTL のパス論理式となる．
したがって，<script type="math/tex">\textbf{A} \phi</script> の反例はすべて <script type="math/tex">\textbf{E} \neg \phi</script> の証拠 (witness) となる．
LTL のパス論理式は否定の下で閉じているため，その反例は常にパスの形となる．
したがって，与えられた LTL 特性に対する反例は，潜在的に無限長となる状態の列 <script type="math/tex">s_0, s_1, \ldots</script> である．
BMC の重要な考え方は，反例の探索を，ある <script type="math/tex">k \in \mathbb{N}</script> に対して 最大でも <script type="math/tex">k</script> 個の遷移をもつパスに限定することである．
<script type="math/tex">k</script> を<strong>境界</strong> (bound) と呼ぶ．</p>
<p>一般的に BMC は，図 10.1 に示す流れで実施される．</p>
<p><center>
<img src="../img/lec12-fig10_1.pdf" width="480">
<br>
図10.1: 有界モデル検査 (BMC) の適用の流れ
</center></p>
<p>この処理は小さな境界 から始まる．
次に，モデルと <script type="math/tex">\phi</script> の否定は，この境界へと展開され，命題論理式を用いて符号化され，ソルバへと渡される．
ソルバが式が充足することを確認した場合，<script type="math/tex">M</script> 上で <script type="math/tex">\phi</script> が反証されると結論づける．
そうでない場合は，境界はより長い反例を探索するために増加される．
10.1.5 節で示すように，考慮しなければならない実行パスの長さの上限を，しばしば計算することができる．
<script type="math/tex">k</script> がこの境界を超えた場合，この性質が満たされると結論づけることができる．
このような境界は<strong>完全性閾値</strong> (completeness threshold) と呼ばれる．
完全性閾値は大きい場合が多いため，ソルバはそこに到達する前に計算資源を使い果たしてしまうかもしれない．</p>
<h3 id="1012-reachability-property">10.1.2 到達可能性 (Reachability Property)</h3>
<p>ここでは，モデルと性質の展開を命題論理式で符号化する方法について述べる．
最初に，性質が <script type="math/tex">p</script> を原子命題として <script type="math/tex">\textbf{AG} p</script> という形式であるような特殊な場合を考える．
この性質は，<script type="math/tex">M</script> のすべてのパスのすべての状態が <script type="math/tex">p</script> でラベル付けされているときに満たされる．
LTL 特性 <script type="math/tex">\textbf{AG} p</script> の反例は <script type="math/tex">\textbf{EF} \neg p</script> の証拠であり，したがって，<script type="math/tex">p</script> を満たさない状態を含むような <script type="math/tex">M</script> のパスである．
以下のパスにおいて，状態 <script type="math/tex">s_{k-1}</script> は <script type="math/tex">\neg p</script> でラベル付けされている．
したがって，このパスは <script type="math/tex">\textbf{EF} \neg p</script> の証拠となる：</p>
<p><img src="../img/lec12-inline1.pdf" width="350"></p>
<p>BMC は記号モデル検査の技術であるため，3.3 節で紹介したクリプキ構造 <script type="math/tex">M</script> の記号的表現に依存する．
<script type="math/tex">M = (S, S_0, R, AP, L)</script>とする．
<script type="math/tex">S_0</script>, <script type="math/tex">R</script>, そして任意の <script type="math/tex">p \in AP</script> についての<strong>特性関数</strong>となる一階の述語を得られることを思い出してほしい．
例えば，状態 <script type="math/tex">s</script> が <script type="math/tex">M</script> の初期状態であることを <script type="math/tex">S_0(s)</script> と書く．
第 3 章で述べられているように，有限状態モデルの <script type="math/tex">R</script>, <script type="math/tex">S_0</script>, <script type="math/tex">p</script> について純粋な命題論理式を得ることができる．</p>
<p>この命題符号化に従えば，<script type="math/tex">M</script> の任意の状態 <script type="math/tex">s</script> は，ブール変数の集合 <script type="math/tex">\{v_1, \ldots, v_n\}</script> への付値と仮定してよい．
したがって，状態 <script type="math/tex">s</script> はベクトル <script type="math/tex">(v_1，\ldots，v_n)</script> への付値である．
BMC の最初のステップは，<script type="math/tex">V_0, \ldots, V_k</script> で表される <script type="math/tex">k+1</script> 個の変数のコピーを導入することである．
<script type="math/tex">V_0</script> の変数は初期状態を符号化するために用いることにし，<script type="math/tex">V_i</script> の変数は <script type="math/tex">i</script> 回の遷移後にシステムが到達する状態のために用いる．
<script type="math/tex">V_i</script> の変数のベクトルを表す略記として <script type="math/tex">s_i</script> を用いる．
記号の濫用 (abuse of notation) として，<script type="math/tex">V_i</script> の変数に割り当てられた値に対応する状態についても <script type="math/tex">s_i</script> と書くことにする．</p>
<p>ここで，<script type="math/tex">\pi = s_0, \ldots, s_k</script> が初期状態から始まり遷移関係 <script type="math/tex">R</script> に従う <script type="math/tex">M</script> の状態の列であるとき，かつそのときのみ充足割当をもつようなベクトル <script type="math/tex">(v_1，\ldots，v_n)</script> 上の論理式 <script type="math/tex">path_k</script> を構成する：
<script type="math/tex; mode=display">\begin{align}
path_k(s_0, \ldots, s_k) \Leftrightarrow S_0(s_0) \wedge \bigwedge_{i=0}^{k-1}R(s_i, s_{i+1}) \tag{10.1}
\end{align}</script>
<script type="math/tex">path_k</script> の最初の連言肢 (conjunct) は <script type="math/tex">s_0</script> が初期状態であることを強制し，2 つめの連言肢 はすべての <script type="math/tex">s_i</script> から <script type="math/tex">s_{i+1}</script> について遷移が存在することを強制する．
この論理式は全部で <script type="math/tex">k</script> 個の遷移関係 <script type="math/tex">R</script> のコピーを含むことが見て取れる．
したがって，式 <script type="math/tex">path_k</script> の大きさは <script type="math/tex">k</script> に対して線形であり，かつ遷移関係の大きさに対して線形である．</p>
<p>
<script type="math/tex">\neg p</script> でラベル付けされた状態を少なくとも一つ含むパスを得るために，以下のように 1 つの連言肢を追加する：
<script type="math/tex; mode=display">\begin{align}
path_k(s_0, \ldots, s_k) \wedge \bigvee_{i=0}^{k} \neg p(s_i) \tag{10.2}
\end{align}</script>
その後，式 10.2 は，9.2 節で述べた手法を用いて，連言標準形 (CNF) の式 <script type="math/tex">f</script> に変換することができる．
この式 <script type="math/tex">f</script> は，式 10.2 が充足可能な場合，かつそのときのみ充足可能であり，したがって，それらは<strong>充足可能性等価</strong> (equisatisfiable) であると言う．
そして，式 <script type="math/tex">f</script> は命題 SAT ソルバに渡される．
<script type="math/tex">f</script> が充足可能であることがわかれば，式 10.2 も充足可能であることになる．</p>
<h4 id="101_1">定理 10.1</h4>
<div class="admonition abstract">
<p class="admonition-title">定理 10.1</p>
<p>式 10.2 は，長さ <script type="math/tex">k</script> 以下の反例がある場合，かつそのときのみ充足可能である</p>
</div>
<div class="admonition note">
<p class="admonition-title">証明</p>
<p>仮に，式 10.2 が充足可能であれば，<script type="math/tex">V_0, \ldots, V_k</script> の全ての変数に対する割当が得られる．
そして，ソルバによって得られた充足割当から，状態の列を抽出することができる．
記号の濫用として，この状態の列を <script type="math/tex">s_0, \ldots, s_k</script> と書くことにする．
この列が <script type="math/tex">\textbf{G}p</script> に対する反例パスであることは容易に理解できる．
この主張のもう一方の向きについては，以下のように示される．
仮に <script type="math/tex">\textbf{G}p</script> に対する長さ <script type="math/tex">k</script> 以下の反例が存在するならば，初期状態から <script type="math/tex">\neg p</script> でラベル付けされた状態への <script type="math/tex">l \le k</script> である長さ <script type="math/tex">l</script> のパス <script type="math/tex">\pi</script> が存在する．
式 10.2 に対する充足割当を得るため，<script type="math/tex">s_0, \ldots, s_l</script> に対して <script type="math/tex">\pi</script> の状態を用いると，<script type="math/tex">path_l(s_0, \ldots, s_l)</script> および <script type="math/tex">\neg p(s_l)</script> が満たされることに気付く．
ここで，<script type="math/tex">R</script> を左全関係だと仮定したことを思い出してほしい．
すなわち，全ての状態は少なくとも 1 つの後状態をもつ．
したがって，すべての <script type="math/tex">l \le i \le k</script> である <script type="math/tex">i</script> について <script type="math/tex">R(s_i, s_{i+1})</script> となる <script type="math/tex">s_{l+1}, \ldots, s_k</script> が存在し，これは <script type="math/tex">path_k(s_0, \ldots, s_k)</script> もまた充足されることを導いている．
(証明終)</p>
</div>
<h4 id="102">例 10.2</h4>
<div class="admonition example">
<p class="admonition-title">例 10.2</p>
<p>3.4 節で用いたクリプキ構造を思い返してみよう．
これは，<script type="math/tex">a</script> または <script type="math/tex">b</script> でラベル付けされた 4 つの状態をもつ：</p>
<p><img src="../img/lec12-inline2.pdf" width="240"></p>
<p>また，モデルの 4 つの状態を 2 つのブール変数で符号化し，<script type="math/tex">v_0</script> と <script type="math/tex">v_1</script> と記述したことも思い返そう．
上記の図では，符号化された <script type="math/tex">v_0</script> と <script type="math/tex">v_1</script> への付値を状態の上部に記載している．
集合を表現するために論理式を用いることを思い出してほしい．
この論理式は，充足割当に対応する要素を含むような集合を表している．
初期状態の集合を表す，<script type="math/tex">v_0</script> および <script type="math/tex">v_1</script> についての以下の論理式が得られる：
<script type="math/tex; mode=display"> S_0(v_0, v_1) = \neg v_0 \wedge \neg v_1 </script>
<script type="math/tex">\{v_0 \mapsto 0, v_1 \mapsto 0\}</script> が，この例における 1 つの初期状態にまさしく対応していることに注意してほしい．
遷移関係は以下で表される．
<script type="math/tex; mode=display">\begin{alignat*}{2}
R(v_0, v_1, v_0', v_1') \quad & = \quad & & \neg v_0 \wedge \neg v_1 \wedge v_0' \wedge \neg v_1' \\
& & \vee \quad & v_0 \wedge \neg v_1 \wedge v_1' \\
& & \vee \quad & \neg v_0 \wedge v_1 \wedge \neg v_0' \wedge \neg v_1' \\
& & \vee \quad & v_0 \wedge v_1 \wedge v_0' \wedge v_1'.
\end{alignat*}</script>
<script type="math/tex">R</script> の 2 番目の節が，遷移 <script type="math/tex">10 \rightarrow 01</script> および <script type="math/tex">10 \rightarrow 11</script> の遷移を許容するため，2 つの遷移を表していることを思い返してほしい．</p>
<p>この例に対して，特性 <script type="math/tex">\textbf{AG}a</script> を用いる．
この原子的な述語 <script type="math/tex">a</script> は，
<script type="math/tex; mode=display"> p(v_0, v_1) = \neg v_0 \vee \neg v_1 </script>
と符号化される．
ここでは <script type="math/tex">k = 2</script> としよう．
したがって，状態変数の 3 つの異なるコピーをもつことになる．
<script type="math/tex">s_0</script> に対応する 1 つめのコピーは <script type="math/tex">\{v_{0,0}, v_{1,0}\}</script>，<script type="math/tex">s_1</script> に対応する 2 つめのコピーは <script type="math/tex">\{v_{0,1}, v_{1,1}\}</script>，そして <script type="math/tex">s_2</script> に対応する 3 つめのコピーは <script type="math/tex">\{v_{0,2}, v_{1,2}\}</script> となる．</p>
<p>ここで，式 10.2 の 2 つの連言肢を示そう．
<script type="math/tex">path_2(s_0, s_1, s_2)</script> として，遷移関係 <script type="math/tex">R</script> の 2 つのコピーを含む，以下の論理式を得られる．
<script type="math/tex; mode=display">\begin{align*}
path_2(s_0, s_1, s_2) \quad & = \quad S_0(s_0) \wedge R(s_0, s_1) \wedge R(s_1,s_2)\\
& = \quad \neg v_{0,0} \wedge \neg v_{1,0} \wedge \\
& \quad\quad \left(
\begin{array}{cl}
        & \neg v_{0,0} \wedge \neg v_{1,0} \wedge v_{0,1} \wedge \neg v_{1,1} \\
\vee & v_{0,0} \wedge \neg v_{1,0} \wedge v_{1,1} \\
\vee & \neg v_{0,0} \wedge v_{1,0} \wedge \neg v_{0,1} \wedge \neg v_{1,1} \\
\vee & v_{0,0} \wedge v_{1,0} \wedge v_{0,1} \wedge v_{1,1} 
\end{array}
\right) \wedge \\
& \quad\quad \left(
\begin{array}{cl}
        & \neg v_{0,1} \wedge \neg v_{1,1} \wedge v_{0,2} \wedge \neg v_{1,2} \\
\vee & v_{0,1} \wedge \neg v_{1,1} \wedge v_{1,2} \\
\vee & \neg v_{0,1} \wedge v_{1,1} \wedge \neg v_{0,2} \wedge \neg v_{1,2} \\
\vee & v_{0,1} \wedge v_{1,1} \wedge v_{0,2} \wedge v_{1,2} 
\end{array}
\right)
\end{align*}</script>
式 10.2 の 2 つめの連言肢は以下の通りである．
<script type="math/tex; mode=display"> \bigvee_{i=0}^{2} \neg p(s_i) = \neg(\neg v_{0,0} \vee \neg v_{1,0}) \vee \neg (\neg v_{0,1} \vee \neg v_{1,1}) \vee \neg (\neg v_{0,2} \vee \neg v_{1,2}) </script>
いずれの連言肢も命題論理式であり，9.2 節で示した技術を用いて CNF へと変換することができる．
そして，これらは SAT ソルバへと渡され，この論理式が充足可能かどうかを判定する．
ここでは，以下の充足割当が得られる．
<script type="math/tex; mode=display"> v_{0,0}=0, v_{1,0}=0, v_{0,1}=1, v_{1,1}=0, v_{0,2}=1, v_{1,2}=1 </script>
この充足割当は，初期状態から <script type="math/tex">a</script> のラベルが付けられていない状態へのパスにおける状態の列に対応している．
したがって，このモデルは <script type="math/tex">\textbf{AG}a</script> を満たさないと結論づけることができる．</p>
</div>
<h3 id="1013-eventually-property">10.1.3 活性 (Eventually Property)</h3>
<p>ここでは，<script type="math/tex">\textbf{AF}p</script> という形の性質を考える．
このような性質は，<script type="math/tex">M</script> のすべてのパスが <script type="math/tex">p</script> が真となる状態を含む場合に成立する．
<script type="math/tex">\textbf{AF}p</script> に対する反例は，その中のすべての状態が <script type="math/tex">\neg p</script> を満たすような無限のパス，すなわち，<script type="math/tex">\textbf{G}\neg p</script> を満たすパスである．
4.6 節において，仮に <script type="math/tex">\textbf{AF} p</script> という性質が偽であるならば，以下のような<strong>ラッソ</strong> (lasso，投げ縄) 型の有限表現をもつ無限パスが存在することを主張している：</p>
<p><img src="../img/lec12-inline3.pdf" width="480"></p>
<p>上記の図の，<script type="math/tex">\pi_0</script> の部分を<strong>ステム</strong> (stem，軸) といい，<script type="math/tex">\pi_1</script> の部分を<strong>ループ</strong> (loop，輪) という．</p>
<p>
<script type="math/tex">k \ge 1</script> について，<script type="math/tex">s_0, \ldots, s_k</script> は，仮に <script type="math/tex">s_k</script> が前の状態のいずれかと等しいならば，ラッソ 型の長さ <script type="math/tex">k</script> のパスということがわかる．
このラッソ 型の性質を述語 <script type="math/tex">lasso_k</script> を用いて表現することにする．
<script type="math/tex; mode=display">\begin{align}
lasso_k(s_0, \ldots, s_k) \Leftrightarrow path_k(s_0, \ldots, s_k) \wedge \bigvee_{i=0}^{k-1}s_i=s_k \tag{10.3}
\end{align}</script>
</p>
<p>その全ての状態が <script type="math/tex">\neg p</script> を満たすような長さ <script type="math/tex">k</script> のラッソ 形状のパスを得るため，以下のようにさらなる連言肢を追加する．
<script type="math/tex; mode=display">\begin{align}
lasso_k(s_0, \ldots, s_k) \wedge \bigwedge_{i=0}^{k-1} \neg p(s_i) \tag{10.4}
\end{align}</script>
<script type="math/tex">s_k</script> は，すでに <script type="math/tex">\neg p</script> を満たすことが要求されている <script type="math/tex">s_i</script> のいずれかと等しいため，<script type="math/tex">s_k</script> への制約は必要ないことに気付いてほしい．
上記の制約を満たすパスは以下のように図示できる:</p>
<p><img src="../img/lec12-inline4.pdf" width="520"></p>
<p>式 10.4 は，<script type="math/tex">k</script> 以下の遷移をもつラッソが存在する場合，かつそのときのみ充足可能である．
<script type="math/tex">k</script> より少ない遷移のラッソ でこの式が満たされる理由を理解するため，より長いラッソ を得るために，ラッソ のループを展開できることに気付いてほしい．</p>
<p>式 10.4 の充足可能性は，上述のように 命題 SAT ソルバを用いて判定できる．
式 10.4 が充足可能であるならば，特性 <script type="math/tex">\textbf{AF}p</script> の反例パスは，ソルバ によって得られた充足割当から抽出できる．
ここで，式 10.4 が充足不能である場合を考えてみよう．
明らかに，<script type="math/tex">k</script> 個以上の遷移をもつ反例が，まだ存在する可能性が残されている．
しかしながら，<script type="math/tex">k</script> 個以下の遷移をもつ反例は存在しないことがわかる．</p>
<h3 id="1014-ltl">10.1.4 LTL に対する有界モデル検査</h3>
<p>第 6 章にて，LTL 式 <script type="math/tex">\phi</script> を<strong>タブロー</strong> (tableau) と呼ばれる公平性を考慮したクリプキ構造へと変換する手順について示した．
このクリプキ構造は <script type="math/tex">\phi</script> に対する BMC 符号化の構築に用いることができる．
公平性を考慮した有限状態クリプキ構造を思い返してみよう．
公平性を考慮した有限状態クリプキ構造は 6-組 <script type="math/tex">(S, S_0, R, AP, L, F)</script> である．ここで，</p>
<ul>
<li>
<script type="math/tex">S</script> は状態の有限集合であり，</li>
<li>
<script type="math/tex">S_0 \subseteq S</script> は初期状態の集合であり，</li>
<li>
<script type="math/tex">R \subseteq (S \times S)</script> は遷移関係であり，</li>
<li>
<script type="math/tex">AP</script> は原子命題の集合であり，</li>
<li>
<script type="math/tex">L</script> は状態からその状態において真となる原子命題の集合へのラベル付け関数であり，</li>
<li>
<script type="math/tex">F = \{P_1, \ldots, P_n\}</script>  (ここで <script type="math/tex">P_j \subseteq S</script>) は公平性制約の集合である．</li>
</ul>
<p>クリプキ構造のパスは，パスが集合 <script type="math/tex">P_i</script> のそれぞれを無限の回数だけ訪れるとき，かつそのときのみ<strong>公平</strong>である．</p>
<p>公平性を考慮したクリプキ構造を用いての BMC 変換の考え方は，第 6 章で導入したモデル検査アルゴリズムに従っている．
LTL 特性 <script type="math/tex">\textbf{A} \phi</script> が与えられるとする．
<script type="math/tex">M \models \textbf{A} \phi</script> であるか判定するため，<script type="math/tex">\phi</script> の否定についての公平性を考慮したクリプキ構造 <script type="math/tex">T_{\neg \phi}</script> を計算し，そして <script type="math/tex">M</script> と <script type="math/tex">T_{\neg \phi}</script> の積を構成する．
得られたモデルを <script type="math/tex">\Psi = (S^{\Psi}, S_0^{\Psi}, R^{\Psi}, AP^{\Psi}, L^{\Psi}, F^{\Psi})</script> で表す．
モデル <script type="math/tex">\Psi</script> の公平なパスは，<script type="math/tex">M</script> における <script type="math/tex">\phi</script> に対する反例であり，したがって，<script type="math/tex">\Psi</script> が公平なパスをもたないとき，かつそのときのみ <script type="math/tex">M \models \textbf{A} \phi</script> となる．</p>
<p>10.1.3 節で示したラッソ構築に基づいて無限パスを表現する，命題論理式を構築できることを思い返してほしい．
ここで，長さ <script type="math/tex">k</script> のラッソとなる公平パスをどのように符号化するかについて示す．
以下の論理式は，長さ <script type="math/tex">k</script> の公平で，ラッソ形状のパスが存在するとき，充足可能となる．
<script type="math/tex; mode=display">\begin{align}
S_0^{\Psi}(s_0) \wedge \bigwedge_{i=0}^{k-1} R^{\Psi}(s_i, s_{i+1}) \wedge \bigvee_{i=0}^{k-1}\left(s_i=s_k \wedge \bigwedge_{P \in F^{\Psi}} Fair_i^P \right) \tag{10.5}
\end{align}</script>
</p>
<p>1 つめの連言肢は状態 <script type="math/tex">s_0</script> が <script type="math/tex">\Psi</script> の初期状態であることを強制する．
2 つめは，2 つの隣接した状態 <script type="math/tex">s_i</script> および <script type="math/tex">s_{i+1}</script> が遷移で接続されていることを保証する．
最後の連言肢は，パスがラッソであり，かつラッソのループにおける状態が全ての公平性制約 <script type="math/tex">P \in F</script> を満たすことを保証する．
状態 <script type="math/tex">s_i</script> から開始するループならびにいずれかの <script type="math/tex">P \in F^{\Psi}</script> に対する公平性条件 <script type="math/tex">Fair_i^P</script> は以下のように定義される．
<script type="math/tex; mode=display"> Fair_i^P \Leftrightarrow \bigvee_{j=i}^{k-1} P(s_j) </script>
<script type="math/tex">s_k</script> は <script type="math/tex">s_i</script> と等しいため，状態 <script type="math/tex">s_k</script> を判定する必要はないことに注意してほしい．
共通の部分論理式を再利用する場合，得られる論理式の大きさは境界 <script type="math/tex">k</script> について線形となる．</p>
<p>これまでと同様に，式 10.5 が充足不能であるならば，長さ <script type="math/tex">k</script> 以下の反例は存在しない．
しかし，より長い反例は存在するかもしれない．</p>
<h3 id="1015-completeness-thresholds">10.1.5 完全性閾値 (Completeness Thresholds)</h3>
<p>BMC では，モデルと特性 <script type="math/tex">\phi</script> は合わさってある深さ <script type="math/tex">k</script> まで展開され，命題論理式となる．
仮にこの式が充足不能であるならば，長さ <script type="math/tex">k</script> 以下の反例は存在しない．
もし境界 <script type="math/tex">k</script> が十分に大きいならば，任意の長さのパスに対して <script type="math/tex">\phi</script> が満たされると結論づけられる．
しかし，どのくらいの大きさなら「十分に大きい」と言えるのか？</p>
<p>
<script type="math/tex">\phi</script> に違反するような <script type="math/tex">M</script> における長さ <script type="math/tex">k</script> の計算 (computation) が存在しないとき，<script type="math/tex">M \models_k \phi</script> と書く．
完全性閾値は以下を保証するような自然数 <script type="math/tex">\mathcal{CT}</script> である．
<script type="math/tex; mode=display"> M \models_{\mathcal{CT}} \phi \Longrightarrow M \models \phi </script>
完全性閾値<script type="math/tex">\mathcal{CT}</script> から得られる恩恵は，<script type="math/tex">k \ge \mathcal{CT}</script> となる BMC インスタンスのどれかが充足不能であると判定した時点で，BMC 手続きを終了できることである．</p>
<p>厳密な (可能な限り最小の) 完全性閾値を決定することが，モデル検査問題自体と同程度の難しさをもつということは容易に理解できる．
仮に <script type="math/tex">M \models \phi</script> であれば，上記の含意は自明に満たされるため，可能な限り最小の完全性閾値は 0 となる．
そうでなければ，最小の完全性閾値は，最も短い反例の長さと等しくなる．
完全性閾値がモデルと特性の両方に依存することも，容易に理解できる (この証明は問題 10.1 および 10.2 に残しておく)．</p>
<p>ここでは，<script type="math/tex">\textbf{AG} p</script> (ここで <script type="math/tex">p</script> は原子命題とする) という形式の特性に対する，非常に単純な完全性閾値を与える．</p>
<h4 id="103">補題 10.3</h4>
<div class="admonition abstract">
<p class="admonition-title">補題 10.3</p>
<p>モデル <script type="math/tex">M</script> が与えられたとき，状態数 <script type="math/tex">|S|</script> は，<script type="math/tex">\textbf{AG}p</script> という形式の任意の特性に対する完全性閾値である．</p>
</div>
<div class="admonition note">
<p class="admonition-title">証明</p>
<p>この特性が満たされない場合を考えよう．
<script type="math/tex">\textbf{AG}p</script> の特性に対する反例は，初期状態から <script type="math/tex">\neg p</script> を満たす状態へのパスの形をもつ．
ここで，<script type="math/tex">|S|</script> 個以下の状態からなる反例が存在することを示す必要がある．
そうではない，すなわち，もっとも短い反例 <script type="math/tex">\pi</script> が <script type="math/tex">|S|</script> より長いと仮定する．
これは，少なくとも 1 つの状態が <script type="math/tex">\pi</script> において 2 回現れなければならない，すなわち，<script type="math/tex">\pi</script> がループを含むことを意味する．
このとき，このループを取り除くことで，新たなパス <script type="math/tex">\pi'</script> を作ることができ，これも同様に <script type="math/tex">\textbf{AG}p</script> の反例となる．
これは <script type="math/tex">\pi</script> がもっとも短い反例ということに矛盾する．
(証明終)</p>
</div>
<p>上述の通り与えられた完全性閾値は正しいが，あまり有用ではない．
通常，状態数はあまりに大きく，この値を境界として用いて構築された充足可能性判定問題は，あまりにも複雑である．</p>
<p>より厳密な完全性閾値を得るために，モデルを，状態を頂点とし遷移を辺とする有向グラフと考えらえることを思い返そう．
グラフの<strong>直径</strong> (diameter) は，グラフ内の異なる任意の 2 つのノード間に存在する最短パスの長さの中でもっとも大きいものである．</p>
<h4 id="104">補題 10.4</h4>
<div class="admonition abstract">
<p class="admonition-title">補題 10.4</p>
<p>モデル <script type="math/tex">M</script> が与えられたとき，グラフ <script type="math/tex">G = (S, R)</script> の直径は，<script type="math/tex">\textbf{AG}p</script> という形式の任意の特性に対する完全性閾値である．</p>
</div>
<p>この証明は，<script type="math/tex">\textbf{AG}p</script> に対するどの反例も，2 つの状態間 (初期状態と <script type="math/tex">\neg p</script> を満たす状態) のパスであるという主張に基づいている．</p>
<p>直径は，任意の特性に対する完全性閾値にはならないことに気付いてほしい．
例として，図 10.2 に与えられたモデルにおける特性 <script type="math/tex">\textbf{AF}p</script> を考えよう．
このグラフの直径は (遷移を数えると) 2 であるが，<script type="math/tex">\textbf{AF}p</script> に対するもっとも短い反例は 5 つの遷移を必要とすることが，容易に理解できる．
<script type="math/tex">\textbf{AF}p</script> という形式の特性に対する完全性閾値は，問題 10.3 の一部として考える．</p>
<p><center>
<img src="../img/lec12-fig10_2.pdf" width="360">
<br>
図10.2: 直径 2 のモデル
</center></p>
<h2 id="102-k-">10.2 <script type="math/tex">k</script>-帰納法による到達可能性検査</h2>
<h3 id="1021-sat">10.2.1 SAT を用いた帰納法</h3>
<p>これまで述べたように BMC は，検証を目的とした場合，モデル <script type="math/tex">M</script> と特性 <script type="math/tex">\phi</script> に対する完全性閾値を超える境界までの <script type="math/tex">M</script> と <script type="math/tex">\phi</script> の展開に依存する．
しかし，我々が決定できる完全性閾値は非現実的なほど大きいことが多い．
本節では，展開を構築要素として利用し，多くの場合わずかな展開のみで特性 <script type="math/tex">\phi</script> を証明可能な技術について説明する．</p>
<p>図 10.3 で与えられる状態 <script type="math/tex">S = \{1, 2, 3, 4, 5\}</script> をもつクリプキ構造 <script type="math/tex">M</script> を用いてこの手法を説明する．
状態 1 が唯一の初期状態である．
状態 1, 2, 3 には <script type="math/tex">p</script> と <script type="math/tex">q</script> を，状態 4 には <script type="math/tex">\neg p</script> と <script type="math/tex">q</script> をラベル付けする．
状態 5 には <script type="math/tex">\neg p</script> と <script type="math/tex">\neg q</script> をラベル付けする．</p>
<p><center>
<img src="../img/lec12-fig10_3.pdf" width="350">
<br>
図10.3: <script type="math/tex">k</script>-帰納法の原則を例示するためのモデル
</center></p>
<p>上記のクリプキ構造は <script type="math/tex">\textbf{AG}p</script> と <script type="math/tex">\textbf{AG}q</script> の両方を満たしていることがわかる．
これは，状態 4 と 5 は到達不可能であるからである．
このグラフの直径が ２ であることは容易にわかり，したがって ２ は，<script type="math/tex">\phi</script> を任意の原子述語のブール結合としたときの <script type="math/tex">\textbf{AG} \phi</script> という形式の特性に対する，このモデルの完全性閾値である．
したがって，<script type="math/tex">k=2</script> で BMC を用いることで，特性 <script type="math/tex">\textbf{AG}p</script> および <script type="math/tex">\textbf{AG}q</script> を立証することができる．</p>
<p>
<script type="math/tex">\textbf{AG} p</script> が満たされることを確認する別の方法は，<strong>帰納原理</strong> (induction principle) の利用である．
あるパラメータ <script type="math/tex">n \in \mathbb{N}</script> のすべての値に対して，主張 <script type="math/tex">\mathcal{Q}(n)</script> を証明するため，以下の 2 つの記述の妥当性を示す．</p>
<ul>
<li>
<script type="math/tex">\mathcal{Q}(0)</script> ：<strong>基礎ケース</strong> (base case) という</li>
<li>
<script type="math/tex">\mathcal{Q}(n-1) \Rightarrow \mathcal{Q}(n)</script> ：<strong>帰納ステップ</strong> (step case) という</li>
</ul>
<p>この原理は，我々の特性を証明するために利用できる．
<script type="math/tex">M</script> の任意の経路 <script type="math/tex">\pi</script> を考えてみよう．
パス <script type="math/tex">\pi</script> の <script type="math/tex">i</script> 番目の状態を <script type="math/tex">\pi(i)</script> で表すことにする．
<script type="math/tex">\textbf{AG}p</script> を証明するため，すべての <script type="math/tex">n</script> に対して <script type="math/tex">p(\pi(n))</script> が成立することを証明する．</p>
<p>
<script type="math/tex">p(\pi(n))</script> を示すため，帰納原理の ２ つのステップを以下のように実行する．</p>
<ul>
<li>基礎ケース では，初期状態のみについて <script type="math/tex">p</script> でラベル付けされることに注意する．</li>
<li>帰納ステップ では，<script type="math/tex">p(\pi(n - 1))</script> が成立することを仮定する．
    すなわち，図 10.3 での <script type="math/tex">p</script> でラベル付けされた状態のみを考える．
    これは <script type="math/tex">\{1, 2, 3\}</script> となる．
    したがって，状態 <script type="math/tex">p(n)</script> は <script type="math/tex">\{1, 2, 3\}</script> の後状態でなければならない．
    この後状態の集合は <script type="math/tex">\{2, 3\}</script> であり，<script type="math/tex">p</script> を満たす．</li>
</ul>
<p>上記の 2 つの観察は，すべての到達可能な状態で <script type="math/tex">p</script> が成立するという帰納的な主張を立証している．
SAT を用いてどのように基礎ケースと帰納ステップの妥当性を確認できるだろうか？
記述 <script type="math/tex">f</script> の<strong>恒真性</strong> (validity) を証明するためには，<script type="math/tex">\neg f</script> が<strong>充足可能でない</strong> (not satisfiable) ことを証明すれば十分であることに注意してほしい．
仮に <script type="math/tex">\neg f</script> が充足可能であれば，その充足割当は <script type="math/tex">\neg f</script>の恒真性に対する反例となる．</p>
<p>したがって，SAT を用いて，上記の 2 つのステップを以下のように実行できる．
基礎ケースはすべての初期状態が <script type="math/tex">p</script> を満たすという主張に対応する．
これは，以下の式の充足可能性を判定することで実現できる．
<script type="math/tex; mode=display">\begin{align}
S_0(s_0) \wedge \neg p(s_0) \tag{10.6}
\end{align}</script>
もし上記の式が充足不能ならば，すべての初期状態は <script type="math/tex">p</script> を満たすことになる．</p>
<p>続いて帰納ステップである．
<script type="math/tex">p(\pi(n-1))</script> であれば <script type="math/tex">p(\pi(n))</script> となることを証明するためには，まず状態 <script type="math/tex">\pi(n-1)</script> と <script type="math/tex">\pi(n)</script> が遷移で接続されている，すなわち <script type="math/tex">R(\pi(n-1), \pi(n))</script> が成り立つことに注目する．
状態 <script type="math/tex">\pi(n-1)</script> を <script type="math/tex">s</script>と表記し，状態 <script type="math/tex">\pi(n)</script> を <script type="math/tex">s'</script> と表記しよう．
そして，<script type="math/tex">(p(s) \wedge R(s, s')) \Rightarrow p(s')</script> の恒真性を判定する．
これは，以下の式の充足可能性の判定に対応する．
<script type="math/tex; mode=display">\begin{align}
p(s) \wedge R(s, s') \wedge \neg p(s') \tag{10.7}
\end{align}</script>
仮にこの式が充足不能であれば，<script type="math/tex">p</script> はモデル <script type="math/tex">M</script> のすべての到達可能状態において成立する．
充足可能性判定器に渡される式は，遷移関係 <script type="math/tex">R</script> の 1 つのコピーしか要求しないことに注意してほしい．</p>
<p>しかしながら，すべての真となる特性が帰納的というわけではない．
上記のモデルは <script type="math/tex">\textbf{AG}q</script> も満たすことを思い返してほしい．
状態 1 は <script type="math/tex">q</script> でラベル付けされているので，基礎ケースは成功する．
しかし，帰納ステップは失敗する．
式 10.7 は <script type="math/tex">s=4</script> かつ <script type="math/tex">s'=5</script> のときに充足可能である．
この問題は，仮定 <script type="math/tex">p(\pi(n-1))</script> が到達可能でない状態も参照している，という事実から生じる．</p>
<h3 id="1022-k-">10.2.2 <script type="math/tex">k</script>-帰納法への一般化</h3>
<p>上で適用された帰納原理の帰納ステップ は，<script type="math/tex">p</script> でラベル付けされたすべての状態の後状態も，<script type="math/tex">p</script> でラベル付けされていると確認することに相当する．</p>
<p>この帰納原理は，適用可能性を改善するために一般化されうる．
1 つのこうした一般化は <script type="math/tex">k</script> 帰納法と呼ばれる．
<script type="math/tex">k</script> 帰納法では，以下のように基礎ケースの基準を<strong>強化</strong>し，帰納ステップの基準を<strong>緩和</strong>している．</p>
<ul>
<li>
<script type="math/tex">\mathcal{Q}(0) \wedge \ldots \wedge \mathcal{Q}(k-1)</script> ：<strong><script type="math/tex">k</script>-帰納法の基礎ケース</strong> (<script type="math/tex">k</script>-induction base case) という</li>
<li>
<script type="math/tex">(\mathcal{Q}(n-k) \wedge \ldots \wedge \mathcal{Q}(n-1)) \Rightarrow \mathcal{Q}(n)</script>： <strong><script type="math/tex">k</script>-帰納法の帰納ステップ</strong> (<script type="math/tex">k</script>-induction step case) という</li>
</ul>
<p>したがって，<script type="math/tex">p</script> でラベル付けされた <script type="math/tex">k</script> 個の状態をもつどんなパスでも，<script type="math/tex">p</script> でラベル付けされた状態が続くことを証明する必要がある．</p>
<p>上記の例における特性 <script type="math/tex">\textbf{AG}q</script> をもう一度考えてみよう．
<script type="math/tex">k = 2</script> に対する <script type="math/tex">k</script> 帰納法の原理を適用し，すべてのパスに対して，すべての <script type="math/tex">n</script> で <script type="math/tex">\pi(n) \models q</script> であることを証明してみよう．</p>
<ul>
<li>基礎ケースを立証するため，初期状態から始まる 2 つの状態によるあらゆるパスにおけるすべての状態を確認する必要がある．
    唯一のこうしたパスは <script type="math/tex">(1,2)</script> である．
    このパスのどちらの状態も <script type="math/tex">q</script> でラベル付けされている．</li>
<li>
<p>帰納ステップを立証するため，<script type="math/tex">q</script> でラベル付けされた 2 つの状態からなるすべてのパスを考える．</p>
<ul>
<li>
<script type="math/tex">\pi_1 = (1, 2)</script>
</li>
<li>
<script type="math/tex">\pi_2 = (2, 3)</script>
</li>
<li>
<script type="math/tex">\pi_3 = (3, 3)</script>
</li>
<li>
<script type="math/tex">\pi_4 = (4, 3)</script>
</li>
</ul>
<p>状態 5 は <script type="math/tex">q</script> でラベル付けされていないため，パス <script type="math/tex">(4, 5)</script> は考慮しないことに注意してほしい．
上述のパスの最後の状態の後状態の集合は，単一要素からなる集合 <script type="math/tex">\{3\}</script> であり，この状態は <script type="math/tex">q</script> でラベル付けされている．
これにより，2 帰納法に対する帰納ステップが立証される．</p>
</li>
</ul>
<p>ある特性 <script type="math/tex">\textbf{AG}p</script> が <script type="math/tex">k</script> 帰納的であることを立証するために，命題 SAT を以下のように適用できる．
まず，<script type="math/tex">k</script> 帰納法の基礎ケース は，境界<script type="math/tex">k-1</script> をもつ <script type="math/tex">\textbf{AG}p</script> の BMC 問題にまさしく対応することに気づいてほしい．
<script type="math/tex">k</script> 帰納法の帰納ステップ は，非常に似た方法で立証することができる．
まず，帰納ステップ の反例は次のような形になることに気づいてほしい：</p>
<p><img src="../img/lec12-inline5.pdf" width="350"></p>
<p>以下の式はこのようなパスが存在するとき，かつそのときのみ充足可能である．
<script type="math/tex; mode=display">\begin{align}
\bigwedge_{i=0}^{k-1}R(s_i, s_{i+1}) \wedge \bigwedge_{i=0}^{k-1}p(s_i) \wedge \neg p(s_k) \tag{10.8}
\end{align}</script>
もしこの式が充足不能であれば，<script type="math/tex">k</script>帰納法に対する帰納ステップ は立証される．
ここで，<script type="math/tex">s_0</script> が初期状態であることは要求されないことに注意してほしい．
これは，境界<script type="math/tex">k</script> に対する BMC インスタンスとの重要な違いである．
実際には，<script type="math/tex">k</script> 帰納法による検証は，モデルの直径よりも小さな <script type="math/tex">k</script> の値で成功することが多い．
仮に式 10.8 が充足可能であれば，この特性に関する結論は何ら導くことはできない．
その場合，次の段階として基礎ケース および帰納ステップ の両方をさらに大きな <script type="math/tex">k</script> の値に対して実行することとなる．
これは，充足可能なインスタンスが真の反例を提供し，これによりその特性が反証されると結論づけられる BMC とは対照的である．</p>
<h3 id="1023">10.2.3 完全性についての議論</h3>
<p>
<script type="math/tex">k</script>-帰納法の原理は，上述のように適用された場合，不完全である．
つまり，その技術では証明できない性質が存在する．
例を理解するため，図 10.3 のモデルに，以下の状態 6 と 7 を与えられた遷移とラベルとともに追加する：</p>
<p><img src="../img/lec12-inline6.pdf" width="120"></p>
<p>この 2 つの状態はどちらも初期状態ではなく，初期状態から到達可能でもない．
したがって，特性 <script type="math/tex">\textbf{AG}q</script> は依然として満たされる．
しかしながら，このとき <script type="math/tex">k</script>-帰納法の帰納ステップ は <script type="math/tex">k</script> の値と関係なく失敗する．
式 10.8 は割当 <script type="math/tex">s_0 \mapsto 6, \ldots, s_{k-1} \mapsto 6</script> および <script type="math/tex">s_k \mapsto 7</script> で満たされる．</p>
<p>
<script type="math/tex">\textbf{AG}p</script> という特性に対する <script type="math/tex">k</script>-帰納法の完全なバリアントを得るためには，以下の連言肢を式 10.8 に追加すればよい．
<script type="math/tex; mode=display">\begin{align}
\bigwedge_{i=0}^{k-1}\bigwedge_{j=i+1}^{k}s_i \neq s_j \tag{10.9}
\end{align}</script>
この連言肢は，帰納ステップに対するどの反例でも全ての状態の組が互いに異なっていることを保証する．
結果として，帰納ステップは <script type="math/tex">M</script> の直径を越えるどのような <script type="math/tex">k</script> の値に対しても成功することが保証される．
上述の例では，<script type="math/tex">\textbf{AG}p</script> に対する帰納ステップは <script type="math/tex">k=2</script> で成功する．
この連言肢を追加しても，反例が見落とされないことは証明できる．
形式的な証明は，<script type="math/tex">\textbf{AG} \phi</script> という形の性質に対して反例が存在する場合は，状態が繰り返されない loop-free なものも存在するという論拠を利用している．</p>
<h2 id="_1">演習問題</h2>
<div class="admonition question">
<p class="admonition-title">問題 10.1 (完全性閾値のモデルへの依存)</p>
<p>モデルに依存しない完全性閾値が存在しないことを示せ．</p>
</div>
<div class="admonition question">
<p class="admonition-title">問題 10.2 (完全性閾値の特性への依存)</p>
<p>特性に依存しない完全性閾値が存在しないことを示せ．</p>
</div>
<div class="admonition question">
<p class="admonition-title">問題 10.3 (<script type="math/tex">\mathbf{AF}p</script> に対する完全性閾値)</p>
<p>グラフの <strong>recurrence diameter</strong> とは，ループをもたないグラフ内の最長のパスの長さである．
recurrence diameter が，<script type="math/tex">\mathbf{AF}p</script> という形をもつ特性の完全性閾値であることを示せ．</p>
</div>
<div class="footnote">
<hr />
<ol>
<li id="fn:59">
<p>A. Biere, A. Cimatti, E. M. Clarke, and Y. Zhu. Symbolic model checking without BDDs. In R. Cleaveland, editor, Tools and Algorithms for Construction and Analysis of Systems, TACAS, volume 1579 of Lecture Notes in Computer Science, pages 193–207. Springer, 1999.&#160;<a class="footnote-backref" href="#fnref:59" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:58">
<p>A. Biere, A. Cimatti, E. M. Clarke, M. Fujita, and Y. Zhu. Symbolic model checking using SAT procedures instead of BDDs. In Design Automation Conference, DAC, pages 317–320. IEEE Computer Society, 1999.&#160;<a class="footnote-backref" href="#fnref:58" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:445">
<p>M. Sheeran, S. Singh, and G. Stålmarck. Checking safety properties using induction and a SAT-solver. In W. A. J. Hunt and S. D. Johnson, editors, Formal Methods in Computer Aided Design, FMCAD, volume 1954 of Lecture Notes in Computer Science, pages 108–125. Springer, 2000.&#160;<a class="footnote-backref" href="#fnref:445" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:381">
<p>K. L. McMillan. Interpolation and SAT-based model checking. In W. A. J. Hunt and F. Somenzi, editors, Computer Aided Verification, CAV, volume 2725 of Lecture Notes in Computer Science, pages 1–13. Springer, 2003.&#160;<a class="footnote-backref" href="#fnref:381" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:78">
<p>A. R. Bradley. SAT-based model checking without unrolling. In R. Jhala and D. A. Schmidt, editors, Verification, Model Checking, and Abstract Interpretation, VMCAI, volume 6538 of Lecture Notes in Computer Science, pages 70–87. Springer, 2011.&#160;<a class="footnote-backref" href="#fnref:78" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
</ol>
</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.annotate"], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d7c377c4.min.js"></script>
      
        <script src="../js/extra.js"></script>
      
        <script src="../js/config.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS_CHTML"></script>
      
    
  </body>
</html>